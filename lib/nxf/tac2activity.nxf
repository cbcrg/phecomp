/*
#################################################################################
### Jose Espinosa-Carrasco. CB/CSN-CRG. April 2015                            ### 
#################################################################################
### Code : 23.01                                                              ###
### Position from tac files                                                   ### 
### ./nextflow tac2activity.nxf --tac_files '*.tac'                           ###
#################################################################################
*/

params.tac_files = "phecomp/data/CRG/20120502_FDF_CRG/*.tac"

tac_files_path = "$HOME/${params.tac_files}"

println "path: $tac_files_path"

tac_files = Channel.fromPath(tac_files_path)

path_tac2pos = "/Users/jespinosa/git/phecomp/lib/c/"

correspondence_f_path = "$HOME/git/pergola/test/position2pergola.txt"
correspondence_f = file(correspondence_f_path)

//path_pergola_scr = "${HOME}/"

/* 
 * Creating results folder
 */
dump_dir = file("$HOME/phecomp/processedData/201205_FDF_CRG/tac2activity/")

dump_dir.with {
     if( !empty() ) { deleteDir() }
     mkdirs()
     println "Created: $dump_dir"
}

/*
 * Extract postion from tac files
 */
process extractPosition {
 
 input:
 file tac from tac_files
 
 // I duplicate the output, one for writing file and one for continue pipe
 output:
// set '*.pos' into act_file
 file '*.pos' into pos_files1
 file '*.pos' into pos_files2
 
 script:
  println "Input name is $tac.name"
   
 """
 ${path_tac2pos}new_tac2pos -file $tac -action position > ${tac}.pos 
 """

}

/*
Another way of duplicating the channels
pos_files1 = Channel.create() 
pos_files2 = Channel.create() 

pos_file.into(pos_files1, pos_files2) 
*/ 
//(pos_file_g, pos_file2bedGr) = pos_file.split (2)
//

/*
 * Writing position file
*/ 

pos_files1
    .subscribe {
        println "Copying pos file: $it"
        it.copyTo( dump_dir.resolve ( it.name ) )
  }

  
/*
 * Join position files
 * Puedo hacer los archivos uno a uno y luego unirlos dejando siempre la coordinadas como las originales
 * Se puede unir despues y hacer luego la coordinadas relativas???
 * Puedo leer directamente el bed o el bed graph no deja de ser un archivo csv
 */
pos_files2Flat = pos_files2.flatten().map { single_pos_file ->
   
   println ">>>>>>>>>>>>>${single_pos_file.name}"
//   println ">>>>>>>>>>>>>${single_pos_file.text}"
   
   def name = single_pos_file.name
   def content = single_pos_file
   [ name,  content ]
}

process joinPosCh {
    
    input: 
    set val (f_pos_name), file ('f_pos') from pos_files2Flat
//    file f_pos from pos_files2
    
    output:
    set val(f_pos_name), file('*.bedGraph') into bedGraph
    set val(f_pos_name), file('*.bedGraph') into bedGraph2
//    set val(f_pos_name), file('*.bed') into bedGraph
//    set val(f_pos_name), file('*.bed') into bedGraph2
//    set val(f_pos_name), file('bedGraph_file') into bedGraph
    //pergola_rules.py -i "/Users/jespinosa/phecomp/processedData/201205_FDF_CRG/tac2activity/20120502_FDF_CRG_c6.tac.pos" -o "/Users/jespinosa/git/pergola/test/position2pergola.txt" -fs ";" -n -nt

//    #cat *.bedGraph > bedGraph_file
//    pergola_rules.py -i $f_pos -o $correspondence_f -fs ";" -n -f bed -nt 

    """ 
    pergola_rules.py -i $f_pos -o $correspondence_f -fs ";" -n -f bedGraph -nt
    """
}

bedGraph2 
    .subscribe { pos_file, bedGraph_files -> 
//        println "pos_file*********** ${pos_file}"
//        println "bedgraph files ****** ${bedGraph_files}"
        
        for ( it in bedGraph_files ) {
//            println "^^^^^^^^^^^^^^$it"
            it.copyTo( dump_dir.resolve ( "${pos_file}${it.name}" ) )
            }  
    }
    
bedGraph_tr = bedGraph.map {pos_file, bedGraph_files ->
        bedGraph_files .collect {
            def pattern = it.name =~/^tr_(\d+).*$/
            //println "##########$it.name"
            //println pattern[0][1]
            def track = pattern[0][1]
            //println "########## ${pos_file} ${track}   ${it}"
            [ pos_file, track,  it ]
        }
    }
    .flatMap()
//    .println()
 
bG_by_track = bedGraph_tr    
    .collectFile { pos, track, file -> 
       [ "bedGraph_$track", file ]   
    }
   // .println() 

// Esto fuera si hago lo de abajo un channel cuando se utiliza queda vacio
//bG_by_track.subscribe  {  
//    println ">>>> name file ${it}"
//}    


process bG_to_relative_coord {       

    input: 
    set val(pos_name), val (track), file ('bedGraph_f') from bG_by_track
//    set val (cage), val (step),
    output:
    set val(track), stdout into rel_coord_bG
    
    println ">>>> name file track"
    
    """
    cat ${bedGraph_f} > /dev/stdout
    """

}

/*
rel_coord_bG.subscribe  {  
//    println ">>>> ${it}"
    println "Copying pos file: $it.name"
}

/*
  
// I could or generate bed files then it would be simple to join by cage just by column
// or I i continue using bedgraph (more compress) then I have to get all bedGraph of a single cage
// read them and generate a new bedGraph file this time with relative coordinates



process joinData {
//    
//    input: 
//    set val (f_pos_name), val (track), file ('bG_file') from bedGraph_tr
//    file f_pos from pos_files2
    
    output:
    set val(f_pos_name), file('*.bedGraph') into bedGraph
    
    """
    cat $bG_file | grep $track >>   
    pergola_rules.py -i $f_pos -o $correspondence_f -fs ";" -n -f bedGraph -nt
    """
    
}

//bedGraph_flat = bedGraph2.map { it ->
//   
//   println "flat ???????????????????${it[1]}"
//   println "??????????? ${it.name}"
////   println ">>>>>>>>>>>>>${single_pos_file.text}"
   

//}
/*
bedGraph.subscribe  {  
    println ">>>> ${it[0]}"
    println "Copying pos file: $it[1]"
    
    file_bedGr = it[1]
    file_bedGr.copyTo( dump_dir.resolve ( "${it[0]}${file_bedGr.name}.bedGraph" ) )
//    oneOutFile.copyTo( resultDirFileOneOut.resolve ( "cage${it[0]}.int" ) )
}

/*
bedGraph2
    .subscribe  {  println "##################### ${it[0]}" }

/*    
//        println ">>>> {bedGr_file}{it[0]}.{bedGr_file}"
//        bedGr_file = it[1]
//        oneOutFile.copyTo( resultDirFileOneOut.resolve ( "{bedGr_file}{it[0]}.{bedGr_file}" ) )
}

/*
 * Writing bedGraph file
 */ 
/* 
bedGraph2
    .flatMap()
    .subscribe { println "File: ${it.name} => ${it.text}" 
        it.copyTo( dump_dir.resolve ( it.name ) ) }
/*    
bedGraph2
    .subscribe {
        println "Copying pos file: $it"
        it.copyTo( dump_dir.resolve ( it.name ) )
  }
*/
  

/*
process {

    input:
    bedGr from bedGraph
    
    output:
    
    
}
*/ 