#!/usr/bin/env perl

use strict;
use FileHandle;
use XML::Simple;
use Data::Dumper;

my $param;
my $d={};
my $HEADER;
my %WEIGHT;
my $diffCh = 0;
our @channel;

if ($#ARGV ==-1)
  {
    
    print "****************** Description *************************\n";
    print "Transform longitudinal phenomic data into tracks viewable in a genome browser\n";
    print "Calculate additional longitudinal statistical parameters\n";
    
    print "****************** Command Line  ***********************\n";
    print "int2browser.pl -data <data_file> -convert <file in file out> -convertMode <channels contained in a single> -outBed <name of bed file> 
           =create <type of file> -generate <type of file> -period <time in hours> -outPhaseBed <name of file> -outCytoband <name of file> -create <genome> -outGenome <name of file> -outdata <name of int file>
    	   -outTimeDiv <name of file> -allFiles <mode> -outdata <file or no>\n";
    print "****************** Flags      **************************\n";
    print "  -data  <file1 file2.. >..........File: input data from file(s).\n";
    print "  -convert       <mode> ...........Mode: 'int2bed' convert an intervals file (raw data) into a bed file\n";
 	  print "  -convertMode   <mode> ...........Mode: 'singleCh2track' each channel in the raw data converted into a single track bed file\n";
 	  print "  .................................Mode: 'allFoodCh2track' food channels combined into the same track bed file\n"; 
 	  print "  .................................Mode: 'allCh2track' food and drink channels combined into the same track bed file\n";  											  	
    print "  -outBed        <file> ...........File:  name of the output Bed file containning the resulting tracks.\n";
    print "  -create        <file> ...........Mode: 'chr' produces a chromosome to be load as a genome with the length of the experiment in seconds\n";    
    #Deprecated
    #print "  -generate     <mode> ...........Mode: 'cytobandFile' produces a cytoband like file with bands corresponding to light/dark phases\n";
    #print "  ................................Mode: 'phase2bed' produces a track with intervals corresponding to light/dark phases in a bed file\n";
    #print "  ................................Mode: 'timeDivision' produces a track with ticks showing a temporal division, by default 1 hour, different time separation provided with -period parameter\n";
    print "	 -cytobandFile <int> ..............Int: '1' produces a cytoband like file with bands corresponding to light/dark phases\n";
    print "	 -phase2bed    <int> ..............Int: '1' produces a track with intervals corresponding to light/dark phases in a bed file\n";
    print "	 -timeDivision <int> ..............Int: '1' 'timeDivision' produces a track with ticks showing a temporal division, by default 1 hour, different time separation provided with -period parameter\n";    
    print "  -period       <int>...............Int: time in hours.\n";
    print "  -window       <parameter>........Parameter: 'Value',... This option slides a window along data calculating the values of the parameter inside this window.\n";
    #Deprecated we can specify this using the same ws and wss
    #print "  -winMode      <mode>.............Mode: 'cumulative', 'discrete' The values of the window are summed up along the time or not.\n";
    print "  -ws           <int>...............Int: Duration of the window in seconds, by default 1800 seconds, 30 min.\n"; 
    print "  -wss          <int>...............Int: Duration of the window in seconds, by default 300 seconds, 5 min.\n";        
    print "  -iniLight     <int>...............Int: Starting of light phase in winter is 7 GMT+1 -> 8 in summer is 6 GMT+2 -> 8. By default 6.\n";
    print "  -winFile      <file>..............File: Set a prefix for all files generated by window.\n";
    print "  -winFormat    <mode>..............Mode: bedGraph, rhmm\n";
    print "  -winCh2comb   <int>...............Int: '1234' combine all channels.\n";
    print "   .................................Int: '12,34' channels 1 and 2, 3 and 4.\n";    
    print "   .................................Int: '12' combine channels 1 and 2\n";
    print "   .................................Int: '34' combine channels 3 and 4.\n";
    print "  -winCombMode  <mode>.............Mode: 'additive' values of the channels add in single intervals, default value\n";
    print "   ................................Mode: 'sign' values of the channels are combined in a track, one channel as negative and the other as positive\n";    
    print "  -winViewLim   <int>...............Int: This option set the browser maximun to be shown in bedGraph window files.\n";
    print "  -winCage2comb <> ..................<>:  Combine values of all cages by group\n";
    print "  -winJoinPhase <> ................Mode:  'mean/all' Combine all values of the same phase,\n"; 
    print "                                          If mode is set to 'all' all values of the same time fraction are added otherwise by default the mean value is given.\n";
    print "  -winJoinPhFormat <> .............Mode:  'bedGraph/table' 'table' result is given in a tabulated format otherwise by default output is a bedGraph file.\n";
    print "  -zeroValues   <mode> ........... Mode:  'T' or 'F' By default set to T, if it is set to T windows with value 0 are exclosed from the file\n";  
    print "  -caseGroup    <mode> ............Mode:  'even/odd' Defines which is the case group\n";
    print "  -splitCh         <> ................<>: Split channels of the same nature on the corresponding to the feeder number (water_1, water_2).\n";
    print "                                          Set by default by \"-winCage2comb\" otherwise joinCages will not work correctly\n";
    print "  -outGenome    <file>.............Value: name of the genome file from \"-create chr\"\n";    
    print "  -outCytoband  <file>.............Value: name of cytoband like file from \"-generate cytobandFile\"\n";
    print "  -outPhaseBed  <file>.............Value: name of phases bed file from \"-generate phase2bed\"\n";
    print "  -outTimeDiv   <file>.............Value: name of temporal division bed file (ticks) from \"-generate timeDivision\"\n";
    print "  -allFiles     <mode>.............Mode:  'genomeBrowser' Produces without setting other parameters a bed file from intervals, a chr to load as a genome and a bed files with the intervals .\n";
    print "  -outdata      <mode>.............Mode: 'no'  Intervals files are not generated or show in standard output\n";
    print "  -out          <file>.............File:  name of output files if parameters for each type of file were not given.\n";
    print "****************** Data Format **************************\n";
    print "  Raw Data\n";
    
    
    
    print "Note: extra fields are ignored\n";
 
    print "****************** Model Format **************************\n";
    print "  #set;<state label>;<state label>;proba;\n";
    print "  #set;<state label>;<emission bin>;proba;\n";
    print "  #comment;<free text>;\n";
    print "\n";
    print "******************Contact **************************\n";
    print "contact: joseantonio.espinosa\@crg.eu\n\n";
    
    die;
  }
  
our @blackGradient = ("226,226,226", "198,198,198", "170,170,170", "141,141,141", "113,113,113", "85,85,85", "56,56,56", "28,28,28", "0,0,0");
our @blueGradient = ( "229,229,254", "203,203,254", "178,178,254", "152,152,254", "127,127,254", "102,102,254", "76,76,173", "51,51,162", "0,0,128");
our @redGradient = ("254,172,182", "254,153,162", "254,134,142", "254,115,121", "254,96,101", "254,77,81", "254,57,61", "254,38,40", "254,19,20");
our @greenGradient = ("203,254,203", "178,254,178", "152,254,152", "127,254,127", "102,254,102", "76,254,76", "51,254,51", "0,254,0", "25,115,25"); 

our @intervals = ("0.03", "0.04", "0.05", "0.06", "0.07", "0.08", "0.09", "1", "1000");

our $colorsGrad = {};
$colorsGrad ->{"water"} = [@blueGradient];
$colorsGrad ->{"drink"} = [@blueGradient];
$colorsGrad -> {"food"} = [@blackGradient];
$colorsGrad -> {"food_sc"} = [@blackGradient];
$colorsGrad -> {"food_cd"} = [@redGradient];
$colorsGrad -> {"food_fat"} = [@greenGradient];

our $colorsSingleTone = {};
$colorsSingleTone -> {"water"} = "0,0,255";
$colorsSingleTone -> {"drink"} = "0,0,255";
$colorsSingleTone -> {"food_sc"} = "0,0,0";
$colorsSingleTone -> {"food_cd"} = "255,0,0";
$colorsSingleTone -> {"food_fat"} = "0,128,0";

@channel = ("Intake 1", "Intake 2", "Intake 3", "Intake 4");

$param = &process_param (@ARGV);

#This parameter is set to separate water into water1 and water2 and all repeated channels so joinCages works correctly
if (exists ($param->{winCage2comb}) || exists ($param->{splitCh})) 
  {    
    $diffCh = 1;    
  }
  
#Reads the data
$d = &readData ($d, $param);

$param = setOutputName ($param);

###RUNNING OPTIONS
#If this option is set the bed files for each cage and channel, the genome and the cytoband file will be generated at the same time
if ($d && $param->{allFiles} eq "genomeBrowser")
  {
  	$param = &setAllOptions ($param);
  }

#if ($d && $param->{generate} eq "cytobandFile")#ponerlo como -citobandFile parametro directo
#  {
#    &changeDayPhases2cytobandLikeFile ($d, $param);
#  }  

if ($d && (exists ($param->{cytobandFile}))) 
  {
    &changeDayPhases2cytobandLikeFile ($d, $param);
  } 

#if ($d && $param->{generate} eq "phase2bed")
#  {
#    &changeDayPhases2bedLikeFile ($d, $param);
#  } 

if ($d && (exists ($param->{phase2bed}))) 
  {
    &changeDayPhases2bedLikeFile ($d, $param);
  } 

#if ($d && $param->{generate} eq "timeDivision")
#  {
#    &timeDiv2bedFile ($d, $param);
#  }
  
if ($d && (exists ($param->{timeDivision}))) 
  {
  	&timeDiv2bedFile ($d, $param);
  }
    
if ($d && $param->{convert} eq "int2bed")
  {  	
    &int2bed ($d, $param);
  } 
  
if ($d && $param->{create} eq "chr")
  {
    &fromInt2chromosome ($d, $param);
  }  

if ($d && (exists ($param->{files2bed}))) 
  {
    &fromLengthFiles2bed ($d, $param);
  }  

if ($d && exists ($param->{window}))
  {
    &data2win ($d, $param);
  }
      
if ($d && $param->{outdata} ne "no")
  {  
    &display_data ($d, $param); 
  }
  
sub readData 
  
  {
    my $d = shift;
    my $p = shift;
    
    if ($p->{data}) 
      {
        my @fl=split (/\s+/, $p->{data});
                
        foreach my $ff (@fl)
          {
            if ( -e $ff) 
              {                                    
                $d = &parse_data ($ff);                
              }
             
            else 
            	{
            		print STDERR "\nERROR: $ff does not exist [FATAL]\n";
            		exit(1);
            	}
          }
        }  
      return ($d);
  }
  
sub parse_data
  {
    my $file=shift;
    my $data={};
    
    my $F=new FileHandle;
    my $linen;
    open($F, $file);
    
    while (<$F>)
      {
	my $line=$_;
	$linen++;
	
	if ( $line=~/#d/)
	  {
	    my $L={};
	    chomp $line;
	    my @v=split (/;/,$line);
	    shift @v; #get rid of the line header(i.e.#d) 
	    while (@v)
	      {
		my $key=shift @v;
		my $value= shift @v;
		$L->{$key}=$value;
		
	      }
	    $L->{linen}=$linen;
	    $L->{period}="1";
	    	    
	    if ($L->{Duration}!=0)
	      {
	    	$L->{Velocity}=$L->{Value}/$L->{Duration};
	      }
	    else
	      {
	    	$L->{Velocity}=0; 
	      }	   
	    
	    if ($L->{Type})
	      {
		my $c=$L->{CAGE};
		my $ch=$L->{Channel};
		my $t=$L->{StartT};
		
		foreach my $k (keys(%$L))
		  {
		    $data->{$c}{$t}{$k}=$L->{$k};
		  }
	      }
	  }
	else
	  {
	    if ( $line=~/Weight/ && $line=~/ANIMALS DATA/)
	      {	   
		    $line=~/.*;(\d+);Weight;([.\d]+)/;
		    my $c=$1;
		    my $w=$2;
		    		   
		    if (!$WEIGHT{$c}{start})
		      {
		        $WEIGHT{$c}{start}=$w;
		      }
		    else 
		      {
		        $WEIGHT{$c}{end}=$w;
  		      }
  		    
  		    $WEIGHT{$c}{max}=($WEIGHT{$c}{max} < $w)?$w:$WEIGHT{$c}{max};
	       }
	     $HEADER.=$line;
	   }
      }
    
    foreach my $c (keys (%WEIGHT))
      {
	if ($WEIGHT{$c}{start}){	$WEIGHT{$c}{delta}=(($WEIGHT{$c}{end}-$WEIGHT{$c}{start})*100)/$WEIGHT{$c}{start};}
      }
    
    #reformat/annotate fields fields
    $data=&channel2correct_channel ($data);
           
    $data=&channel2Nature($data);
         
    return $data;
  }

sub display_data
  {
    my $d=shift;
    #my $file=shift;
    my $file= $param->{outdata};
    my $F= new FileHandle;

    if (!$file){open ($F, ">-");}
    else {open ($F, ">$file");}

    if ($param->{output}!~/R/)
      {	
	    print $F "$HEADER";
	    
      	foreach my $c (sort ({$a<=>$b}keys(%$d)))
      	  {
      	    foreach my $i (sort {$a<=>$b}keys (%{$d->{$c}}))
      	      {
        		print $F "#d;";
        		foreach my $k (sort (keys (%{$d->{$c}{$i}})))
        		  {
        		    print $F "$k;$d->{$c}{$i}{$k};";
        		  }
      		    print $F "\n";
      	      }
      	  }
	    close ($F);
      }
    else
      {
    	&data2R_header($d);
    	&data2R_records($d);
    	
    	close ($F);
      }
  }  
  
sub channel2correct_channel
    {
      #THis function corrects all sorts of labelling errors made by the acquisition equipment
      my $d=shift;
      my ($tot, $n);

      foreach my $c (keys (%$d))
	{
	  foreach my $t (keys (%{$d->{$c}}))
	    {
	      my $Name=$d->{$c}{$t}{Name};
	      my $Channel=$d->{$c}{$t}{Channel};
	      my $Caption=$d->{$c}{$t}{Caption};
	      
	      $Channel=~/.*(\d)/;
	      my $i=$1;
	      
	      #This is meant to correct the wrong labelling of the intakes: 1 and 2 are always drink, 3 and 4 are always food
	      if ($i==1){$d->{$c}{$t}{Caption}="Drink 1";}
	      elsif ($i==2){$d->{$c}{$t}{Caption}="Drink 2";}
	      elsif ($i==3){$d->{$c}{$t}{Caption}="Food 1";}
	      elsif ($i==4){$d->{$c}{$t}{Caption}="Food 2";}
	      else
		{
		  print STDERR "\n*** ERROR: unknown index for the Intake\n";
		}
	      if ($Caption ne $d->{$c}{$t}{Caption}){$tot++;}
	      $n++;
	    }
	}
      print STDERR "\nclean_data: relabled $tot values out of $n\n";
      return $d;
    }

sub channel2Nature
      {
	# This function creates a label describing the precise content of each intake
	my $d=shift;
		
	foreach my $c (sort(keys (%$d)))
	  {
	    foreach my $t (sort(keys (%{$d->{$c}})))
	      {
			my $Name=$d->{$c}{$t}{Name};
			my $Channel=$d->{$c}{$t}{Channel};
			my $Caption=$d->{$c}{$t}{Caption};
			
			$Channel=~/.*(\d)/;
			my $i=$1;
			my $Nature="";
		
			$d->{$c}{$t}{SlotI}=$i;
			
			$Name=lc ($Name);
			$Name=~s/\s//g;
			
			if ((length ($Name)) == 4 && ($Name =~/(w)(w)(s)(s)/ || $Name =~/(w)(w)(c)(s)/ || $Name=~/(w)(w)(s)(c)/ || $Name=~/(w)(w)(c)(s)/ || $Name=~/(w)(w)(f)(f)/))
			  {
			    
		      	if ($i==1) 
		      		{
		      			$Nature.=&anot2nature ($1);		      			
		      			($diffCh)? $Nature.="_$i" : $Nature=$Nature;#many times we have water in both channels, separate them into water_1 and water_2		      			
		      		}
		      		
		      	elsif ($i==2) 
		      		{
		      			$Nature.=&anot2nature ($2);
#		      			$Nature.="_$i";#many times we have water in both channels, separate them into water_1 and water_2		      
                        ($diffCh)? $Nature.="_$i" : $Nature=$Nature;#many times we have water in both channels, separate them into water_1 and water_2	
		      		}
		      		
		      	elsif ($i==3) 
		      		{
		      			$Nature.=&anot2nature ($3);
                        ($3 == $4 && $diffCh)? $Nature.="_$i" : $Nature=$Nature;		      			
		      		}
		      		
	      		elsif ($i==4) 
	      			{
	      				$Nature.=&anot2nature ($4);
                        ($4 == $3 && $diffCh)? $Nature.="_$i" : $Nature=$Nature;	      				
	      			}		
				
				#print STDERR "$Nature\n";
			  }
			      
			elsif ($Caption=~/Food/){$Nature="food";}
			
			elsif ($Caption=~/Drink/ && $diffCh)
			  {
			  	my $nat = lc($Caption);
			  	
			  	#separating old annotated files into drink_1 and drink_2
			  	$nat =~ s/\s/_/g;
			  	$Nature = $nat;
			  }
			  
			else {$Nature="drink";}
		
			if ($Nature eq "food")
			  {
			    #print STDERR "--$Name--\n";
			    			     
				if ($Name eq "sc"){$Nature.="_sc";}
			    
			#####################
			#Modification 31/08/2010
			#Female file different codification of CD slots
			    
			    #elsif ($Name =~/cd/ && $Nature eq "food")
		    	elsif (($Name =~/cd/ || $Name=~/choc/) && $Nature eq "food")
			      {
					if    ($i==1 && (($Name =~/slota/) ||($Name =~/ina/) )){$Nature.="_cd";}
					elsif ($i==2 && (($Name =~/slotb/) ||($Name =~/inb/) )){$Nature.="_cd";}
					elsif ($i==3 && (($Name =~/slotc/) ||($Name =~/inc/) )){$Nature.="_cd";}
					elsif ($i==4 && (($Name =~/slotd/) ||($Name =~/ind/) )){$Nature.="_cd";}
					else  {$Nature.="_sc";}
			      }
				          
				    
				else
			      {
				     #print "ERROR: $Name\n";
			      }
			  }
			
			if    ($Name =~/sc/ && $Nature eq "food"){$Nature="sc_".$Nature;}		
			#elsif ($Name =~/cd/){$Nature="cd_".$Nature;}
			elsif (($Name =~/cd/ || $Name =~ /choc/) && $Nature eq "food"){$Nature="cd_".$Nature;}
			#########end modification 31/08/2010
			
			$d->{$c}{$t}{Nature}=$Nature;
		
	      }
	  }
	  
	return $d;
  }

#anot2nature match the given symbol of annotation with the appropiated type of food or liquid, i.e. (s->standard chow, f->fat food)
sub anot2nature
	{
		my $annot = shift;
		
		
		SWITCH: 
                {
                  ($annot eq "w") && do 
                    { 
                      return ("water");
                      last SWITCH;
                    };
                    
                  ($annot eq "s") && do 
                    { 
                      return ("food_sc");                          
                      last SWITCH;
                    };
                      
                  ($annot eq "f") && do 
                    { 
                      return ("food_fat");                             
                      last SWITCH;
                    };
                    
                  ($annot eq "c") && do 
                    { 
                      return ("food_cd");                          
                      last SWITCH;
                    };  
                }
         
         print STDERR "FATAL ERROR: ANNOTATION PROVIDED $annot DOES NOT CORRESPOND WITH ANY OF THE VALID ANNOTATIONS\n";
         print STDERR "             ASK FOR THE INCLUSSION OF THIS ANNOTATION\n";
         die;
		
	}

#############################################
#                                           #
# FUNCTIONS                                 #
#                                           #
#############################################

#####################
# Parameters
#####################
  
sub process_param
  
  {
    my @arg=@_;
    my $cl=join(" ", @arg);
    
    my @commands=split (/\s\-+/,$cl);
    my $param={};
    
    
    foreach my $c (@commands)
      {
        if (!($c =~ /\S/)){next;}
        $c =~ /(\w+)\s*(.*)\s*/;
        my $k = $1;
        if ($2 != 0 && !$2) {$param->{$k} = 1;}
        else {$param->{$k} = $2;}
        $param->{$k} =~ s/\s*$//;
      }
    
    return check_parameters ($param);
  }

sub check_parameters 
  
  {
    my $p = shift;
    my $rp = {};
    
    $rp->{data} = 1;
    $rp->{out} = 1;
    $rp->{convert} = 1;
    $rp->{convertMode} = 1;
    $rp->{outBed} = 1;
    $rp->{cytobandFile} = 1;
    $rp->{outCytoband} = 1;
    $rp->{phase2bed} = 1;   
    $rp->{outPhaseBed} = 1;
    $rp->{period} = 1;
    $rp->{outGenome} = 1;    
    $rp->{create} = 1;
    $rp->{generate} = 1;
    $rp->{process} = 1;
    $rp->{outFileDiv} = 1;
    $rp->{files2bed} = 1;   
    $rp->{timeDivision} = 1;
    $rp->{outTimeDiv} = 1;
    $rp->{window} = 1;
    $rp->{iniLight} = 1;
    $rp->{ws} = 1;
    $rp->{wss} = 1;
    $rp->{wp} = 1; 
    $rp->{winMode} = 1;
    $rp->{winFile} = 1;
    $rp->{winFormat} = 1;
    $rp->{winCh2comb} = 1;
    $rp->{winCombMode} = 1;
    $rp->{winViewLim} = 1;   
    $rp->{allFiles} = 1;
    $rp->{outdata} = 1;
    $rp->{winCage2comb} = 1;
    $rp->{caseGroup} = 1;
    $rp->{winJoinPhase} = 1;
    $rp->{winJoinPhFormat} = 1;
    $rp->{splitCh} = 1;
    $rp->{zeroValues} = 1;
    
    foreach my $k (keys (%$p))
      {
        if (!$rp->{$k})
          {
            print STDERR "\n****ERROR: $k is an unknown pararmeter[FATAL]***\n";
            die;
          }
          
        else
          {
            print STDERR "PARAM: -$k ---> [$p->{$k}]\n";
          }
      }
    return $p;
  }
  
sub changeDayPhases2cytobandLikeFile
  {
    my $d = shift;
    my $param = shift;
    my $ph = $param->{phase};
    my $iniLightPh = $param->{iniLight};
    my $outCytobandFile = $param->{outCytoband};
    #By the moment I set the delta phase to 12 in case the phases are not symetric then I should see how to further implement the code
    my $deltaPh = 12; # = $A->{deltaPh}; my deltaPhTwo = 24 - $deltaPh;  
    
    #my ($a,$b, $start, $end, $delta, $secAfterLastMidnight, $firstPhLightChange, $day, $file);
    my ($a, $b, $day, $file, $start, $end, $firstPhLightChange);  
    
    $start=$end=-1;
    
    #Traversing all intervals to set initial and end time
    ($start, $end) = &firstAndLastTime ($d, $param);
    
    $firstPhLightChange = &getFirstChange2LightPh ($d, $param, $start, $end);
    
    #opening the file
    $file = $outCytobandFile."_cytoBand".".txt";
    
    my $F= new FileHandle;
	vfopen ($F, ">$file");
	
    #is start more than 12 hours before first change to light phases? -> then start is occurring during the previous light phase     
    if ($start < ($firstPhLightChange - ($deltaPh * 3600)))
    	{
    		print $F "chr1", "\t", $start - $start, "\t", $firstPhLightChange -($deltaPh * 3600)- $start, "\t", "light", "\t", "gneg\n";
    		print $F "chr1", "\t", $firstPhLightChange -($deltaPh * 3600) - $start, "\t", $firstPhLightChange - $start, "\t", "dark", "\t", "gpos25\n";
    	}
    else 
    	{
    		print $F "chr1", "\t", $start - $start, "\t", $firstPhLightChange - $start, "\t", "dark", "\t", "gpos25\n";
    	}	

    my $lastEnd = $firstPhLightChange;
    my $lastPhase = "dark";
    my $colour = "gpos25";       
    	  
   	for ($a=$firstPhLightChange + 1; $a < $end; $a ++)
   		{	
   			$a = $a + 43199;
   			
   			if ($lastPhase eq "dark") {$lastPhase="light"; $colour = "gneg";}
   			else {$lastPhase = "dark"; $colour = "gpos25";}
   			
   			print $F "chr1", "\t", $lastEnd-$start, "\t", $a-$start, "\t", $lastPhase, "\t", $colour, "\n";
   			
   			$lastEnd = $a;
   		}
   		
   	close ($F);
   		
   	printf "      Cytoband like file in: $file\n";
  }

#This function will create a bed file within which intervals correspond to division into dark/light phases of the time length of the experiment
sub changeDayPhases2bedLikeFile
  {
    my $d = shift;
    my $param = shift;
    my $ph = $param->{phase};
    my $iniLightPh = $param->{iniLight};
    my $outBedPhFile = $param->{outPhaseBed};
    #By the moment I set the delta phase to 12 in case the phases are not symetric then I should see how to further implement the code
    my $deltaPh = 12; # = $A->{deltaPh}; my deltaPhTwo = 24 - $deltaPh;  
    
    my ($a, $b, $day, $file, $start, $end, $firstPhLightChange); 

    $start=$end=-1;
    
    #Traversing all intervals to set initial and end time
    ($start, $end) = &firstAndLastTime ($d, $param);
    $firstPhLightChange = &getFirstChange2LightPh ($d, $param, $start, $end);
    
    #opening the file
    $file = $outBedPhFile."_Phase".".bed";
    
    my $F= new FileHandle;
	vfopen ($F, ">$file");
	
	print $F "track name=\"Day phases\" description=\"Track annotating the dark and light phase of the experiment\" visibility=2 color=0,0,255 useScore=1 priority=user\n";
	
	#print $firstPhLightChange, "\n";
    
    #Printing the first interval
    #print $firstPhLightChange -($deltaPh * 3600), "\t", $start-$start;
    
    #is start more than 12 hours before first change to light phases? -> then start is occurring during the previous light phase     
    if ($start < ($firstPhLightChange - ($deltaPh * 3600)))
    	{
    		print $F "chr1", "\t", $start - $start, "\t", $firstPhLightChange -($deltaPh * 3600)- $start, "\t", "light", "\t", "0\n";
    		print $F "chr1", "\t", $firstPhLightChange -($deltaPh * 3600) - $start, "\t", $firstPhLightChange - $start, "\t", "dark", "\t", "1000\n";
    	}
    else 
    	{
    		print $F "chr1", "\t", $start - $start, "\t", $firstPhLightChange - $start, "\t", "dark", "\t", "1000\n";
    	}	

    my $lastEnd = $firstPhLightChange;
    my $lastPhase = "dark";
    my $scorePhase = 1000;       
    	  
   	for ($a=$firstPhLightChange + 1; $a < $end; $a ++)
   		{	
   			$a = $a + 43199;
   			
   			if ($lastPhase eq "dark") {$lastPhase="light"; $scorePhase = 0;}
   			else {$lastPhase = "dark"; $scorePhase = 1000;}
   			
   			print $F "chr1", "\t", $lastEnd-$start, "\t", $a-$start, "\t", $lastPhase, "\t", $scorePhase, "\n";
   			
   			$lastEnd = $a;
   		}
   		
   	close ($F);
   		
   	printf "      Bed like file with day phases in: $file\n";
  }

sub getFirstChange2LightPh
  {
    my $d = shift;
    my $param = shift;
    my $start = shift;
    my $end = shift;
    my $ph = $param->{phase};
    my $iniLightPh = $param->{iniLight};
    
    my ($delta, $secAfterLastMidnight, $firstPhLightChange); 
           
    #Traversing all intervals to set initial and end time
    ($start, $end) = &firstAndLastTime ($d, $param);
    
    if (!$ph) {$ph="lightDark"; $delta = 3600*12;}    
    elsif ($ph eq "lightDark") {$delta = 3600*12;}
    elsif ($ph eq "day") {$delta = 3600*24;}
    
    if (!$iniLightPh)
      {
        $iniLightPh = 6;
        print STDERR "WARNING: Beginning of the light phase has been set to 8:00 AM as you didn't provide any info (iniLight)\n\n";
      }
    elsif ($iniLightPh !~ /^\d+$/) 
      {
        $iniLightPh = 6;
        print STDERR "WARNING: Beginning of the light phase has been set to 6:00 AM GMT (8:00 spanish summer time) as the value provided by iniLight: $iniLightPh is not a number\n\n";
      }
    elsif ($iniLightPh < 1 || $iniLightPh > 24)
      {
        $iniLightPh = 6;
        print STDERR "WARNING: Beginning of the light phase has been set to 6:00 AM GMT (8:00 spanish summer time) as the value provided by iniLight: $iniLightPh is not in the correct range\n\n";
      }
    
    #Searching the first change to light phase taking place in the data
    $secAfterLastMidnight = $start % (3600 * 24);                
   
    if ($secAfterLastMidnight > (3600 * $iniLightPh))
      {
      	#As the start is after the change to light, we calculate unix midnight, add seconds until change to light and we add a whole day
        $firstPhLightChange =  $start - $secAfterLastMidnight  + ($iniLightPh * 3600) + (24 * 3600);    
      }
    else 
      {
        $firstPhLightChange =  $start - $secAfterLastMidnight  + ($iniLightPh * 3600);
      }
      
    return ($firstPhLightChange);
          
  }	
#Function to generate a file displaying tick marks each period of time selected
sub timeDiv2bedFile
	{
		my $d = shift;
	    my $param = shift;
	    my $outTimeDivFile = $param->{outTimeDiv};
	    
	    my ($period, $start, $end, $file, $visibility, $priority, $i, $j);
	    
	    if (exists ($param->{period}))
	    	{
	    		$period = 3600 * $param->{period};	    			
	    	}
	    else 
	    	{
	    		$period = 3600;
	    		print STDERR "INFO: Time division have been set to 1 hour a it was not provided using \"-period\" parameter\n";
	    	}	
	    
	    
	    #Traversing all intervals to set initial and end time    	
    	($start, $end) = &firstAndLastTime ($d, $param);
    	
    	$file = $outTimeDivFile."TimeDiv.bed";
	    
    	my $F= new FileHandle;
		vfopen ($F, ">$file");
		
		#Add track line specifications for the genome browser
      	#link to field info http://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
      	$visibility = 2;#by the moment hardcoded in future it might be a parameter
      	$priority = "user"; #from higher to low priority "user", "map", "genes", "rna", "regulation", "compGeno"
      	
    	print $F "track name=", "\"ticks each $period sec\"", " ";
    	print $F "description=", "\"Blue ticks every $period seconds\" ";
    	print $F "visibility=", $visibility, " ";			    				
    	print $F "color=0,0,255 ";#blue
    	print $F "priority=", $priority, " ";
    	print $F "\n";
	    	    
	    $end -=$start;
	    $i = 1;
	    
	    while ($i < $end)
	    	{
	    		$j = $i+5;
	    		print $F "chr1", "\t", "$i", "\t", "$j", "\n";
	    		$i= $i + $period;
	    	}
	    
	    print $F "\n";
	    close ($F);
	}    	
  
sub fromInt2chromosome
	{
		my $d = shift;
	    my $param = shift;
	    my ($a,$b, $start, $end, $outGenomeFile, $file); 
	   	my $outGenomeFile = $param->{outGenome};
	   	    
	    $start=$end=-1;
	    
	    #Traversing all intervals to set initial and end time    	
    	($start, $end) = &firstAndLastTime ($d, $param);    	
    	
    	#opening the file
    	$file = $outGenomeFile."Genome.fa";
    	
    	my $F= new FileHandle;
		vfopen ($F, ">$file");
		
    	print $F ">chr1\n";
    	
    	for ($a=$start - $start; $a < $end - $start; $a ++)
   			{
   				print $F "N";
   			}
   			
   		print $F "\n";
    	close ($F);
    	
		printf "      Chromosome for browser in: $file\n";
	}

sub fromLengthFiles2bed
	{
		my $d = shift;
	    my $param = shift;
	    my $outFileDiv = $param->{outFileDiv};
	    my $switch = 0;
	    
	    my ($intFile, $pIntFile, $intFileName, $endT, $outFile);
	    my @aryFiles;
	    $pIntFile = "";
	    
	    #Traversing all intervals to set initial and end time    	
    	my ($globalStart, $globalEnd) = &firstAndLastTime ($d, $param);
    			
	    foreach my $t (sort {$a<=>$b}keys (%{$d->{"1"}}))
	    	{
				#print "track file information\n";
				$intFile = $d->{"1"}{$t}{File};
				#print "----- $intFile\n";
				if ($intFile ne $pIntFile)
  					{
  						push (@aryFiles, $intFile);
  						print "track file information\n";
						  								
  						$intFileName = &path2fileName ($intFile);
  						$endT = $d->{"1"}{$t}{EndT};
  						print "----- $intFileName\t$endT\n";		  										  					
    					#print  "$k;$d->{$c}{$t}{$k};";		
  					} 
				
				$pIntFile = $intFile;
	    	}	
	    
	    #opening the file
    	$outFile = $outFileDiv."_fileDiv".".bed";
    	   	
    	my $F= new FileHandle;
		vfopen ($F, ">$outFile");
		
		#In this case we use itemRgb this flag is used to use define a precise color for each band inside track file
		print $F "track name=\"Int Files div\" description=\"Track annotating the length of each int file\" visibility=2  useScore=1 priority=user itemRgb=\"On\"\n";
		
		my $score=1000;		
		my $color="255,0,0";#red
		
	    foreach my $f (@aryFiles)
	    	{
	    		print STDERR "$f\n";#del
	    			    		
	    		my ($start, $end);
    			$start=$end=-1;    			
	    		 
	    		foreach my $c (sort ({$a<=>$b}keys(%$d)))
	  				{
	    				foreach my $t (sort {$a<=>$b}keys (%{$d->{$c}}))
	      					{	
	      						if ($f ne $d->{$c}{$t}{File}) {next;}
	      						my $cstart = $d->{$c}{$t}{StartT};
	    	    				my $cend = $d->{$c}{$t}{EndT};	      						
	      						
	      						if ($start==-1 || $start>$cstart){$start=$cstart;}
	      						if ($end==-1 || $end<$cend){$end=$cend;}
	      					}
	  				}
	  				  			
	  			print $F "chr1", "\t", $start-$globalStart, "\t", $end-$globalStart, "\t", $f, "\t", $score, "\t", "+","\t",$start-$globalStart, "\t", $end-$globalStart, ,"\t", $color, "\n";
	  			#$score = ($score == 0)? 1000 : 0;
	  			$color = ($color eq "255,0,0")? "255,215,0" : "255,0,0";
	    	}
	    
    	close ($F);
	    	
	}
	
sub firstAndLastTime
	{
		my $d = shift;
    	my $param = shift;
    	
    	my ($start, $end);
    	
    	$start=$end=-1;
    	
		foreach my $c (sort(keys (%$d)))
	      {
	    	foreach my $t (sort(keys (%{$d->{$c}})))
	    	  {	    	    
	    	    my $cstart = $d->{$c}{$t}{StartT};
	    	    my $cend = $d->{$c}{$t}{EndT};
	    	    
	    	    if ($start==-1 || $start>$cstart){$start=$cstart;}
	    	    if ($end==-1    || $end<$cend){$end=$cend;}
	    	  }
	      }
	      
		return ($start, $end);	  
	}
	     	
sub int2bed
	{
		my $d = shift;
    	my $param = shift;    	
    	
    	if (!exists ($param->{convertMode})) {$param->{convertMode} = "allFoodCh2track";}#by default food and water channel combined in a single track
    	
    	my $convertMode = $param->{convertMode};
    	    	   	
    	my ($start, $end, $startInt, $endInt, $nature, $value); 
    	
    	($start, $end) = &firstAndLastTime ($d, $param);
    	
    	#print $start, "\t", $end, "\n";#del
    	
    	if ($convertMode eq "singleCh2track")
    		{    		
    			&int2bedSingleCh2track ($d, $param, $start, $end);
    		}
    	elsif ($convertMode eq "allFoodCh2track")
    		{    			
    			&int2bedAllFoodCh2track ($d, $param, $start, $end);
    		}
    	elsif ($convertMode eq "allCh2track")
    		{
    			print STDERR "This option should be developed\n"; 
    			die;
    		}
    	else
    		{
    			print STDERR "FATAL ERROR: problem while processing convertMode option\n";
    		}    	    		      	    	        
	}

sub int2bedSingleCh2track
	{
		my $d = shift;
    	my $param = shift;
    	my $start = shift;
    	my $end = shift;
    	my $bedName = $param->{outBed};
    	my ($startInt, $endInt, $nature, $value, $chN);
    	
    	#Defines the initial display mode of the annotation track. Values for display_mode include: 0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
    	my $visibility = 2;#by the moment hardcoded in future it might be a parameter
    	my $color = "0,0,0";
    	my $priority = 20; #from higher to low priority "user", "map", "genes", "rna", "regulation", "compGeno"
    	
		foreach my $c (sort ({$a<=>$b} keys(%$d)))
	  		{
	    		foreach my $ch (@channel)
	    			{
	    				$ch =~ m/(\d)/;
	    				$chN = $1;		  
	    					    					    				
	    				#Getting the nature of the channel (food_SC, fat_food, ...)
	    				foreach my $t (sort (keys (%{$d->{$c}})))
      						{      							      								
      							if ($d->{$c}{$t}{Channel} eq $ch)
      								{
      									$nature = $d->{$c}{$t}{Nature};       									
      									$color = &natureValue2color ($nature);      									      												 
      									last;		
      								}
      							else
      								{
      									next;
      								}	
      						}
      							    				
	    				my $file = $bedName."cage".$c."ch".$nature.$chN.".bed";
	    				
	      				my $F= new FileHandle;
	      				
	      				vfopen ($F, ">$file");
	      				
	      				#Add track line specifications for the genome browser
	      				#link to field info http://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
	    				print $F "track ";
	    				print $F "name=", "\"cage ", $c, "\;", $nature, "\"", " ";
	    				print $F "description=", "\"cage ", $c, "\;", $nature, "\"", " ";
	    				print $F "visibility=", $visibility, " ";
	    				print $F "color=", $color, " ";
	    				print $F "useScore=", "1", " ";
	    				print $F "priority=", $priority, " ";
	    				print $F "\n";
	    					    					    				
    					foreach my $t (sort (keys (%{$d->{$c}})))
      						{
      							if ($d->{$c}{$t}{Channel} ne $ch)
      								{next;}
      							else
      								{	
	      								$startInt = $d->{$c}{$t}{StartT} - $start;
	    								$endInt = $d->{$c}{$t}{EndT} - $start;	    	
	    								my $debugValue = $d->{$c}{$t}{Value};							
	    								$value = int ($d->{$c}{$t}{Value} * 10000 + 0.5);
	    								#print $F "chr".$c, "\t", $startInt, "\t", $endInt, "\n";	    								 
	    								#print $F "chr1", "\t", $startInt, "\t", $endInt, "\t", $nature, "\t", $value, "\n";#too many nature labels	
	    								print $F "chr1", "\t", $startInt, "\t", $endInt, "\t", "$debugValue","\t", $value, "\n";				
	      							}	      					    				   					
	      					}
	      		
	      				close ($F);
	      				printf "      Intervals cage $c, channel $ch, nature $nature in: $file\n";
	  				}
	  		}
	}

sub int2bedAllFoodCh2track
	{
		my $d = shift;
    	my $param = shift;
    	my $start = shift;
    	my $end = shift;
    	my $bedName = $param->{outBed};
    	my ($startInt, $endInt, $nature, $value, $score, $chN);
    	
    	#Defines the initial display mode of the annotation track. Values for display_mode include: 0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
    	my $visibility = 2;#by the moment hardcoded in future it might be a parameter
    	my $color = "0,0,0";
    	my $priority = 20; #from higher to low priority "user", "map", "genes", "rna", "regulation", "compGeno"
    	    		   		   
    	foreach my $c (sort ({$a<=>$b} keys(%$d)))
	  		{
	  			#Two files open one for drink annotations and a second one for food annotations
		    	#Drink file
		    	my $Dfile = $bedName."cage".$c."Drink.bed";
			   	my $FD= new FileHandle;
			   	vfopen ($FD, ">$Dfile");			   	
	      		
	      		#Add track line specifications for the genome browser
      			#link to field info http://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
    			print $FD "track ";
    			print $FD "name=", "\"cage ", $c, "\;", "drink", "\"", " ";
    			print $FD "description=", "\"cage ", $c, "\;", "drink", "\"", " ";
    			print $FD "visibility=", $visibility, " ";			    				
    			print $FD "itemRgb=\"On\"", " ";#different natures have different color
    			print $FD "priority=", $priority, " ";
    			print $FD "\n";	
    					
			   	#Food File
			   	my $Ffile = $bedName."cage".$c."Food.bed";
			   	my $FF= new FileHandle;
			   	vfopen ($FF, ">$Ffile");
			   	print $FF "track ";
    			print $FF "name=", "\"cage ", $c, "\;", "food", "\"", " ";
    			print $FF "description=", "\"cage ", $c, "\;", "food", "\"", " ";
    			print $FF "visibility=", $visibility, " ";			    				
    			print $FF "itemRgb=\"On\"", " ";#different natures have different color
    			print $FF "priority=", $priority, " ";
    			print $FF "\n";
			   	      					
      			foreach my $t (sort (keys (%{$d->{$c}})))
      				{
      					if ($d->{$c}{$t}{Channel} eq "Intake 1" ||  $d->{$c}{$t}{Channel} eq "Intake 2")
      						{		      							      							    					    					    	
		    					$startInt = $d->{$c}{$t}{StartT} - $start;
    							$endInt = $d->{$c}{$t}{EndT} - $start;
    							$value = $d->{$c}{$t}{Value};	    								
    							$score = int ($value * 10000 + 0.5);
    							$nature = $d->{$c}{$t}{Nature};
    							#$color = &nature2color ($nature);
    							$color = &natureValue2color ($nature, $value);
    							#print STDERR "------------$color\n";
    							print $FD "chr1", "\t", $startInt, "\t", $endInt, "\t", "", "\t", $value, "\t", "+","\t",$startInt, "\t", $endInt, "\t", $color, "\n";							      								      					    				   								      						      		      					
      						}
      					
      					elsif ($d->{$c}{$t}{Channel} eq "Intake 3" ||  $d->{$c}{$t}{Channel} eq "Intake 4")
      						{		      							      							    					    					    	
		    					$startInt = $d->{$c}{$t}{StartT} - $start;
    							$endInt = $d->{$c}{$t}{EndT} - $start;	
    							$value = $d->{$c}{$t}{Value};    								
    							$score = int ($value * 10000 + 0.5);
    							$nature = $d->{$c}{$t}{Nature};
    							#$color = &nature2color ($nature);
    							$color = &natureValue2color ($nature, $value);
    							#print STDERR "------------$color\n";
    							    							
    							print $FF "chr1", "\t", $startInt, "\t", $endInt, "\t", "", "\t", $value, "\t", "+","\t",$startInt, "\t", $endInt, "\t", $color, "\n";							      								      					    				   								      						      		      					
      						}      												
	  				}
	  				
  				close ($FD);
				close ($FF);
      				
      			printf "      Intervals cage $c, drink channels are in: $Dfile\n";
      			printf "      Intervals cage $c, foods channels are in: $Ffile\n";
	  		}	
	}

sub natureValue2color
	{
		my $nature = shift;
				
		my ($value, $color, $i);
		
		if (@ARGV) {$value = shift;} 	
	
		if ($value) 
      		{

      			for ($i=0; $i < scalar (@intervals); $i++)
      				{
						if ($value <= $intervals [$i])
      						{      						
      							$color = $colorsGrad -> {$nature} [$i];
      							if ($color eq "") {print STDERR "FATAL ERROR: The color can not be assigned because the $nature is not declared\n"; die;}
      							last;		
      						}
      					else
      						{
      							#print STDERR "FATAL ERROR: The color of an interval with value $value and nature $nature couldn't be assigned\n";
      						}
      					}      					
      		}
      	else
      		{
      			$color = $colorsSingleTone->{$nature};
      		}
      	
      	return ($color)
	}

##Deprecated
#sub data2winDistroOld
#	{
#		my $d = shift;
#    	my $param = shift;
#  		my ($start, $end, $startInt, $winIndex, $startInt, $endInt, $chN, $ch, $acuValue, $nature);
#    	
#  		#Checking parameteres if empty setting default
#  		my $winParam = $param -> {window}? $param->{window} : "Value"; 
#    	my $winSize = $param->{ws}? 3600 * $param->{ws} : 1800; #by default win 30 minuts    	
#    	my $winFile = $param -> {winFile}? $param -> {winFile} : "";
#    	my $winMode = $param -> {winMode}? $param -> {winMode} : "discrete"; #by default discrete
#    	my $viewLimits = $param -> {winViewLim}? $param -> {winViewLim} : "0.5";
#    	$viewLimits = "0:".$viewLimits;
#    	 
#    	#Defines the initial display mode of the annotation track. Values for display_mode include: 0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
#    	my $visibility = "full";#by the moment hardcoded in future it might be a parameter
#    	my $color = "200,100,0";
#    	my $altColor = "0,100,200";
#    	my $priority = "20";
#    	my $type = "bedGraph";
#    	
#    	 
#    	($start, $end) = &firstAndLastTime ($d, $param);
#    	
#    	foreach my $c (sort ({$a<=>$b} keys(%$d)))
#	  		{	
#	  			foreach my $ch (@channel)
#	  				{	  					
#	  					$ch =~ m/(\d)/;
#	    				$chN = $1;	  					
#	  					$acuValue = 0;
#	  					$startInt = 1;
#	  					$endInt = $winSize;
#	  					
#	  					#Getting the nature of the channel (food_SC, fat_food, ...) for file name
#	    				foreach my $t (sort (keys (%{$d->{$c}})))
#      							{      							      								
#      							if ($d->{$c}{$t}{Channel} eq $ch)
#      								{
#      									$nature = $d->{$c}{$t}{Nature};       									      									  									      												
#      									last;		
#      								}
#      							else
#      								{
#      									next;
#      								}	
#      						}
#      						
#	  					my $file = $winFile."cage".$c."ch".$nature.$chN.".bedGraph";
#	    				
#	      				my $F= new FileHandle;
#	      				
#	      				vfopen ($F, ">$file");
#	      				
#	      				#Add track line specifications for the genome browser
#	      				#link to field info http://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
#	    				print $F "track ";
#	    				print $F "type=$type ";	    				
#	    				print $F "name=", "\"cage ", $c, "\;", "ch", $nature, "\"", " ";
#	    				print $F "description=", "\"cage ", $c, "\;", $nature, "\"", " ";
#	    				print $F "visibility=", $visibility, " ";
#	    				if ($viewLimits ne "auto") {print $F "viewLimits=", $viewLimits, " ";} 
#	    				print $F "color=", $color, " ";
#	    				print $F "altcolor=", $altColor, " ";
#	    				print $F "priority=", $priority, " ";
#	    				print $F "\n";
#	    					
#	  					foreach my $t (sort (keys (%{$d->{$c}})))
#      						{   
#      							if ($d->{$c}{$t}{Channel} eq $ch)
#      								{
#      									my $newT = $t-$start;
#      									
#      									#Intervals smaller than first time
#      									if ($newT > $endInt)
#      										{
#      											while ($endInt < $newT)
#      												{
#      													print $F "chr1\t$startInt\t$endInt\t$acuValue\n";
#      													if ($winMode eq "discrete") {$acuValue = 0;}
#      													
#      													$startInt += $winSize;
#      													$endInt += $winSize;      											      												
#      												}
#      											
#      											$acuValue = $acuValue + $d->{$c}{$t}{$winParam};      											        										
#      										}
#      									
#      									elsif ($newT => $startInt && $newT <= $endInt)
#      										{
#      											my $ccc = $d->{$c}{$t}{$winParam};      											    										
#      											$acuValue = $acuValue + $d->{$c}{$t}{$winParam};      											       										
#      										}
#      									
#      									else
#      										{      											
#      											print STDERR "FATAL ERROR: Something got wrong";
#      											die;      											
#      										}		
#      								}
#      							else
#      								{
#      									next;
#      								}
#      							      							   							      								      							      							
#      						}
#      						
#      						close ($F);
#	      				    printf "      Results of cumulative window for $winParam of cage $c, channel $ch, nature $nature in: $file\n";
#	  				}
#	  				 			      					
#      		}
#	} 

#This function controls all the parameters of window option
sub data2win
	{
		my $d = shift;
    	my $param = shift;    	
    	my ($winSize2dataWinDistro);
    	my ($hashUnitWin, $hashWin) = {};
    	
    	#Checking parameteres if empty setting default
  		my $winParam = $param -> {window}? $param->{window} : "Value"; 
    	#my $winSize = $param->{ws}? 3600 * $param->{ws} : 1800; #by default win 30 minuts
    	my $winSize = exists ($param->{ws})? $param->{ws} : 1800; #by default win 30 minuts in seconds    	
    	my $winStepSize = exists ($param->{wss})? $param->{wss} : 300; #by default win 5 minuts in seconds
    	my $winCombMode = (exists ($param->{winCh2comb}) && !exists ($param->{winCombMode}))? "additive" : $param->{winCombMode};     	    	    	       
    	my $winBindCageCase = (exists ($param->{winCage2comb}) && !exists ($param->{caseGroup}))? "even" : $param->{caseGroup};     	    	    	       
    	#my $winBind = (exists ($param->{winCage2comb}) && !exists ($param->{caseGroup}))? "even" : $param->{caseGroup};     	    	    	       
    	my $winFormat = exists ($param->{winFormat})? $param->{winFormat} : "bedGraph"; #by default bedGraph
    	my $winMode = $param -> {winMode}? $param -> {winMode} : "discrete";
    	  
    	#our $param->{winCh2comb} = (!exists ($param->{winCh2comb}) && exists ($param->{winCombMode}))? "12,34" : $param->{winCh2comb}; 
    	if (!exists ($param->{winCh2comb}) && exists ($param->{winCombMode}))
    	 {
    	   print STDERR "FATAL ERROR: winCh2comb was not set\n";
    	 }
    	 
    	my $winFile = $param -> {winFile}? $param -> {winFile} : "";
    	#my $winMode = $param -> {winMode}? $param -> {winMode} : "discrete"; #by default discrete
    	my $viewLimits = $param -> {winViewLim}? $param -> {winViewLim} : "0.5";
    	$viewLimits = "0:".$viewLimits;
    	
    	#Check whether winsize is divisible by the win step    
    	if ($winStepSize == 0)
    		{
    			print STDERR "FATAL ERROR: It is not possible to set window step size to 0, maybe you wanted to set it to the same as window size (discrete window)\n";
    			die;    			
    		}
    	#If there is not wss the data is divided in discrete intervals
    	elsif ($winSize == $winStepSize)
    		{
    			$hashUnitWin = &data2winDistro ($d, $param, $winSize);
    		}
    		
    	#hashUnitWin will be a hash with data divided in intervals of size equal to the greater common divisor between ws and wss
    	elsif ($winSize > $winStepSize)
			{   			    						
    	  $winSize2dataWinDistro = &euclideanAlgGCD ($winSize, $winStepSize);     			  			
				$hashUnitWin = &data2winDistro ($d, $param, $winSize2dataWinDistro);							
			}
    	else
    		{
    			print STDERR "FATAL ERROR: window size should be equal or greater than window step size\n";
    			die; 
    		}  
    	
    	#Joining all intervals of the same group (case/control)
    	if (exists ($param->{winCage2comb}))
        {
          $hashUnitWin = &joinCages ($hashUnitWin, $winBindCageCase);
          #print Dumper ($hashUnitWin); #del
        }
      
      #Combining channels if the parameter  winCh2comb is set
    	#here it is possible to use unionBedGraphs a bedtools tool to combine hashUnitWin first I should write bedGraph temp files first
    	#http://seqanswers.com/forums/showthread.php?t=6424
    	#the hash could be dump into a temp bedGraph file, and a bedGraph file could be easily read into a hash   
    	if (exists ($param->{winCh2comb}))
    	 {
    	   if ($winCombMode eq "additive")
    	     {
    	       $hashUnitWin = &joinChannelsUnitWin ($hashUnitWin);
    	     }
    	   #If parameter is sign no channels have to be joined, channels are discriminated by sign  
    	   elsif ($winCombMode eq "sign")
    	     {
    	       $hashUnitWin = $hashUnitWin;
    	     }
    	   else
    	     {
    	       print STDERR "FATAL ERROR: winCombMode \"$winCombMode\" provided is unknown\n";
    	       die;  
    	     }    	       	 
    	 }
    	 
      #$hashUnitWin = $hashUnitWin;
    	    	
  	  #In this case, no sliding window, discrete intervals, the $hashUnitWin it is directly the output  	    	
      if ($winStepSize == $winSize)
        {
          $hashWin = $hashUnitWin;
        }
      #The discrete intervals of the GCD size will be joint by the ws and in a sliding window with wss	
      else
        {		
      	  $hashWin = &joinUnitWindow2winSize ($hashUnitWin, $winSize, $winStepSize, $winSize2dataWinDistro);
        }
      
      if (exists ($param->{winJoinPhase}))
        {                   
          $hashWin = &joinByPhase ($hashWin, $param);
        } 
         
      if ($winMode eq "binary")
          {
            &writeWindowBinary ($hashWin, $winFile);
          }  
      elsif ($winFormat eq "bedGraph")
        {
          if ($winCombMode eq "" || $winCombMode eq "additive") 
    	     {     	    	
            #print Dumper ($hashWin);#del
            &writeWindowBedFile ($hashWin, $winFile);
    	     }
    	    elsif ($winCombMode eq "sign")
    	     {    	   
    	       &writeWindowBedFileSign ($hashWin, $winFile);    	  
    	     }    	    
        }      
  	       
  }	


### data2winDistro
#Returns a hash with all the values of intervals within ws of the field set in "window"
#hashWin will have the following structure:
#'1' => {                                                         Cage
#                   '1' => {                                      Channel
#                             'Nature' => 'foodfood',
#                             'data' => [                         Data will be an ary with each of the windows being an occurrence
#                                         {
#                                           'startInt' => 1,
#                                           'endInt' => 300,
#                                           'chr' => 'chr1',
#                                           'acuValue' => 0
#                                         },

sub data2winDistro 
	{
		my $d = shift;
    	my $param = shift;
    	my $winSize = shift;
    	
  		my ($start, $end, $startInt, $winIndex, $startInt, $endInt, $chN, $ch, $acuValue, $nature);
    	
  		#Checking parameteres if empty setting default
  		my $winParam = $param -> {window}? $param->{window} : "Value"; 
    	my $winMode = $param -> {winMode}? $param -> {winMode} : "discrete"; #by default discrete
    	
    	my $hashWin = {};
    	 
    	($start, $end) = &firstAndLastTime ($d, $param);
    	#print STDERR "start is $start\n";#del
    	
    	foreach my $c (sort ({$a<=>$b} keys(%$d)))
	  		{
	  					  			
	  			foreach my $ch (@channel)
	  				{	  					
	  					$ch =~ m/(\d)/;
	    				$chN = $1;	  					
	  					$acuValue = 0;
	  					$startInt = 1;
	  					$endInt = $winSize;
	  					
	  					#Getting the nature of the channel (food_SC, fat_food, ...) for file name
	  					#We inspect the hash in a reverse way because some files start with habituation phase, both food channels have food_sc
	    				foreach my $t (sort ({$b<=>$a} keys (%{$d->{$c}})))	    				
      						{      							      								
      							if ($d->{$c}{$t}{Channel} eq $ch)
      								{
      									$nature = $d->{$c}{$t}{Nature};       									      									  									      												      									
      									last;		
      								}
      							else
      								{
      									next;
      								}	
      						}
      												
						  my @aryCh; #An ary for each channel
	    					
	  					foreach my $t (sort (keys (%{$d->{$c}})))
      						{   
      							if ($d->{$c}{$t}{Channel} eq $ch)
      								{
      									my $newT = $t-$start;
      									
      									#Intervals smaller than first time
      									if ($newT > $endInt)
      										{
      										  #I can find several intervals before the first reaching the first time with signal
      											while ($endInt < $newT)
      												{      													
														    my $h = {};
														
														    $h->{"chr"} = "chr1";
														    $h->{"startInt"} = $startInt;
														    $h->{"endInt"} = $endInt;
														    
#														    if ($winMode eq "binary" && $acuValue != 0) 
#														      {														        
#														        $h->{"acuValue"} = 1;
#														      }
#														    elsif ($winMode eq "binary" && $acuValue == 0)
#														      {
#														        $h->{"acuValue"} = 0;
#														      }
#														    else
#														      {    
														        $h->{"acuValue"} = $acuValue;
#														      }
														
														    push (@aryCh, $h);
      													
      													if ($winMode eq "discrete" || $winMode eq "binary") {$acuValue = 0;}
      													
      													$startInt += $winSize;
      													$endInt += $winSize;
      											      													
      												}
      											
      											$acuValue = $acuValue + $d->{$c}{$t}{$winParam};      											        										
      										}
      									
      									elsif ($newT => $startInt && $newT <= $endInt)
      										{
      											my $ccc = $d->{$c}{$t}{$winParam};
      											    											
      											$acuValue = $acuValue + $d->{$c}{$t}{$winParam};
      											       											
      										}
      									
      									else
      										{      											
      											print STDERR "FATAL ERROR: Something went wrong";
      											die;      											
      										}		
      								}
      							else
      								{
      									next;
      								}
      							      							   							      								      							      							
      						}

						$hashWin->{$c}{$chN}{data} = \@aryCh ;
						$hashWin->{$c}{$chN}{Nature} = $nature ;
	  				}
	  				 			      					
      		}
      		      		
      		return ($hashWin);      		
	} 

#Takes a hash with hashWin structure and joint the channels given by -winCh2comb parameter  
sub joinChannelsUnitWin
	{		
		my $hUnitWin = shift;
		my ($hChComb) = {};
		my ($hJoinChUnitWin) = {};		
		my ($comb, $i);

		$hChComb = &readWinComb ();

		#combine2Ch will do something similar as bedtools do when combining bedfiles, it could be change in the future
		foreach my $c (sort ({$a<=>$b} keys (%$hUnitWin)))
	  		{
	  			my $hProcessedCh = {};
	  				
	  			foreach $comb (keys (%$hChComb))
	  				{
	  					if (exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"2"})) 
	  						{
	  							
	  							$hJoinChUnitWin = &combine2Ch ($hUnitWin, $hJoinChUnitWin, $c, 1, 2);	  							
	  							
	  							if (exists ($hChComb->{$comb}{"3"}) && exists ($hChComb->{$comb}{"4"}))
	  								{	  									
	  									$hJoinChUnitWin = &combine2Ch ($hUnitWin, $hJoinChUnitWin, $c, 3, 4);	  									
	  									$hJoinChUnitWin = &combine2Ch ($hJoinChUnitWin, $hJoinChUnitWin, $c, 12, 34, "TRUE");	  									
	  								}
	  								  								  								  							  					
	  						}
	  					elsif (exists ($hChComb->{$comb}{"3"}) && exists ($hChComb->{$comb}{"4"})) 
	  						{
	  							$hJoinChUnitWin = &combine2Ch ($hUnitWin, $hJoinChUnitWin, $c, 3, 4);;	  								
	  						}
	  					
	  					elsif (exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"3"}) || exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"4"}) 
	  						   || exists ($hChComb->{$comb}{"2"}) && exists ($hChComb->{$comb}{"3"}) || exists ($hChComb->{$comb}{"2"}) && exists ($hChComb->{$comb}{"4"}))
	  						{
	  							print STDERR "FATAL ERROR: It is not possible to join channels of different nature (ie food and drink), cage $c\n";
	  							die;
	  						}	  							  				
	  				}	  						
	  		}
	  		
	  	return ($hJoinChUnitWin);
	}	

#Reads the channels to combine given by -winCh2comb parameter
#12, 34 for example will means join ch 1 and 2, and 3 and 4
sub readWinComb 
	{		
		my ($chN, $i, $comb, $tag);
		my ($hJoinWin, $hCh) = {};
		my (@listOfComb);
		
		$tag = "";
		$i = 1;
		
		if ($param -> {winCh2comb} =~ m/,/) 
			{			
				@listOfComb = split (/,/, $param->{winCh2comb});
				
				foreach $comb (@listOfComb)
					{
						$hCh = splitAry ($comb, $tag, $hCh, $i);
						$i++;											
					}										
			}
		else
			{
				$hCh = splitAry ($param->{winCh2comb}, $tag, $hCh, $i);		
			}	
			
		return ($hCh);
	}

#This function receives the source hash to combine channels, the hash that will hold the result, the cage that is being combine and the channels to combine
#and performs the joining. 
#$SwDelHash switch will tell if the resulting hash has to be initialized before adding any information of it not
sub combine2Ch
	{
		my $hUnitWin = shift;
		my $hJoinChUnitWin = shift;
		my $c =  shift;
		my $ch1 = shift;
		my $ch2 = shift;
		my $SwDelHash = shift;
		
		my ($i);
						  							
  		$hJoinChUnitWin->{$c}{$ch1.$ch2}{"Nature"} = $hUnitWin->{$c}{$ch1}{"Nature"}.$hUnitWin->{$c}{$ch2}{"Nature"};	
  							
  		my $data1 = ($hUnitWin->{$c}{$ch1}{data});
  		my $data2 = ($hUnitWin->{$c}{$ch2}{data});
  		my @aryJoinCh;
  								  								  						
  		for($i = 0; $i < scalar (@$data1)-1; $i++)  
  			{
  				my $h1 = $data1->[$i];
  				my $h2 = $data2->[$i];
  				my $hJoin = {};
  				
  				#At the end of the intervals if one channel has signal for more time the program dies, change by a warning
  				if ($h1->{"startInt"} != $h2->{"startInt"}) 
  					{  						
  						my $t = $h1->{startInt};
  						my $t2 = $h2->{startInt};	
  						print STDERR "Warning: Problem while joining the channels, intervals are not the same $t----$t2\n";
#  						die;
  					}
  									
  				foreach my $key (keys (%$h1))
  					{
  						if ($key =~ /acuValue/)
  							{
  								$hJoin->{$key} = $h1->{$key} + $h2->{$key};
  							}
  						else 
  							{
  								$hJoin->{$key} = $h1->{$key};
  							}	  												  																						
  					}
  										
  				push (@aryJoinCh, $hJoin);	
  			}
  								  							
  		$hJoinChUnitWin->{$c}{$ch1.$ch2}{data} = \@aryJoinCh;
  		
  		if ($SwDelHash eq "TRUE") 
			{
				print STDERR "Delete hash\n";
				delete ($hJoinChUnitWin->{$c}{1}); #If we are going to combine 12 with 34 we have to delete them from the hash
				delete ($hJoinChUnitWin->{$c}{2});
				delete ($hJoinChUnitWin->{$c}{3});
				delete ($hJoinChUnitWin->{$c}{4});
				delete ($hJoinChUnitWin->{$c}{12});
				delete ($hJoinChUnitWin->{$c}{34}); 
			}
				
  		return ($hJoinChUnitWin);		
	}

#Function to join the unitary window of GCD size into the resulting window of window size each given window size step		
sub joinUnitWindow2winSize
	{
		my $hashUnitWin = shift;
		my $ws = shift;
		my $wss = shift;
		my $wsUnit = shift;
		my $Nwins2Jump = $wss/$wsUnit;
		my $Nwins2Join = $ws/$wsUnit;
		my ($i, $j);
		my $hR = {}; 
		
		foreach my $c (sort ({$a<=>$b} keys(%$hashUnitWin)))
	  		{
	  			foreach my $ch (sort ({$a<=>$b} keys(%{$hashUnitWin->{$c}})))	  			  			
	  				{	  						  						  			
	  					my $aryData = $hashUnitWin->{$c}{$ch}{data};	  									  						  	
				  		my @aryJoinWin;				  
				  		my $length = scalar (@$aryData) - $Nwins2Join;
				  			  								  										  		
				  		for ($ i= 0; $i < $length; $i= $i + $Nwins2Jump)  
				  			{				  								  				
				  				my $hJoin = {};
				  				my $v = 0;
				  							  		
						  		for ($j=0; $j <= $Nwins2Join - 1; $j++)  
						  			{
						  										  										  				
						  				my $h = $aryData->[$i+$j];						  				

										$v += $h->{acuValue};

						  				if ($j == 0)
						  					{
						  						$hJoin->{startInt} = $h->{startInt};
						  						$hJoin->{chr} = $h->{chr};	
						  					}
						  				elsif ($j == ($Nwins2Join - 1))
						  					{
						  						$hJoin->{endInt} = $h->{endInt};
						  						$hJoin->{acuValue} = $v
						  					}						  									  				
						  			}
						  			
						  			push (@aryJoinWin, $hJoin);
				  			}
	  					
	  					$hR->{$c}{$ch}{data} = \@aryJoinWin ;
						  $hR->{$c}{$ch}{Nature} = $hashUnitWin->{$c}{$ch}{Nature} ;	
	  					
	  				}
	  		}
	  	return ($hR);
	}

#This function writes bedGraph format window file	
sub writeWindowBedFile
	{
		my $h = shift;
		my $winFile = shift;
		my $winParam = $param->{window};
		my $zerosOut = $param->{zeroValues}? $param->{zeroValues} : "T"; 
		
		my $i = 0;
		my ($chr, $startInt, $endInt, $acuValue);
		
		#Defines the initial display mode of the annotation track. Values for display_mode include: 0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
		my $viewLimits = $param -> {winViewLim}? $param -> {winViewLim} : "0.5";
    	my $visibility = "full";#by the moment hardcoded in future it might be a parameter
    	my $color = "200,100,0";
    	my $altColor = "0,100,200";
    	my $priority = "20";
    	my $type = "bedGraph";	
    	
    	foreach my $c (sort ({$a<=>$b} keys(%$h)))
	  		{	
	  			foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
	  				{	  		
	  					my $nature = $h->{$c}{$chN}{Nature};
	  					my $aryData = $h->{$c}{$chN}{data}; 
	  								
    					my $file = $winFile."cage".$c."ch".$nature.$chN.".bedGraph";
    				
    					my $F= new FileHandle;
    				
			      	vfopen ($F, ">$file");
			      				
			      	#Add track line specifications for the genome browser
			      	#link to field info http://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
				    	print $F "track ";
				    	print $F "type=$type ";	    				
				    	print $F "name=", "\"cage ", $c, "\;", "ch", $nature, "\"", " ";
				    	print $F "description=", "\"cage ", $c, "\;", $nature, "\"", " ";
				    	print $F "visibility=", $visibility, " ";
				    	if ($viewLimits ne "auto") {print $F "viewLimits=", $viewLimits, " ";} 
				    	print $F "color=", $color, " ";
				    	print $F "altcolor=", $altColor, " ";
				    	print $F "priority=", $priority, " ";
				    	print $F "\n";
				    	
				    	for ($i = 0; $i < scalar (@$aryData); $i++)
				    		{
				    			my $hItem = $aryData->[$i];
				    			
				    			$acuValue = $hItem->{'acuValue'};				    							    		
				    			
				    			$chr = $hItem->{'chr'};
				    			$startInt = $hItem->{'startInt'};
				    			$endInt = $hItem->{'endInt'};
				    			
				    			#print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			 
				    			if ($zerosOut ne "F") 
				    			 {
				    			   print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			 }
				    			else 
				    			 {
				    			   if ($acuValue > 0)
				    			     {
				    			       print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			     }
				    			   else
				    			     {
				    			       ;
				    			     }
				    			 }				    							    							    		
				    		}
				    	
				    	close ($F);
	      			print STDERR "      Results of cumulative window for $winParam of cage $c, channel $chN, nature $nature in: $file\n";
	  				}
	  		}
	}

#This function dump the data into rhmm format
#  #d;1;Nindex;field;x;bin;NBin

sub writeWindowBinary 
  {
    my $h = shift;
    my $winFile = shift;
    my $i = 0;
    my $file = ""; 
    my ($chr, $startInt, $endInt, $acuValue, $bin);
    my $zerosOut = $param->{zeroValues}? $param->{zeroValues} : "T";
    my $winParam = $param->{window};
    my $winMode = $param -> {winMode}? $param -> {winMode} : "discrete"; #by default discrete
    my $winFormat = exists ($param->{winFormat})? $param->{winFormat} : "bedGraph"; #by default bedGraph
    my $natures = {};
    
#    foreach my $c (sort ({$a<=>$b} keys(%$h)))
#		  {	
#			 foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
#			   {		  		
#				    $natures->{$chN} = $h->{$c}{$chN}{Nature};  				    	  					
#				 }
#			 next;  			 	
#		  }
#		  
#  	print Dumper ($natures);
#  	die;	  
#    my $file = $winFile."cage".$c."ch".$nature.$chN.".hmm";
#    print $F "#comment;Format: int2rhmm.01";
#		print $F "\n";
##				    	
				    	
    foreach my $c (sort ({$a<=>$b} keys(%$h)))
	  		{	
	  			foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
	  				{	  		
	  					my $nature = $h->{$c}{$chN}{Nature};
	  					my $aryData = $h->{$c}{$chN}{data}; 
	  					
	  					if ($winFormat eq "rhmm")
                {			
    					    $file = $winFile."cage".$c."ch".$nature.$chN.".hmm";    					   
                }
              elsif ($winFormat eq "bedGraph")
                {
                  $file = $winFile."cage".$c."ch".$nature.$chN.".bedGraph";    				
                }   
    					
    					my $F= new FileHandle;
    					vfopen ($F, ">$file");
				    	
				    	if ($winFormat eq "rhmm")
                {			
    			      	#Type of file
    			      	print $F "#comment;Format: int2rhmm.01";
    				    	print $F "\n";
                }
              elsif ($winFormat eq "bedGraph")
                {

			      	    #Type of file
			      	    #Defines the initial display mode of the annotation track. Values for display_mode include: 0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
		              my $viewLimits = $param -> {winViewLim}? $param -> {winViewLim} : "0.5";
                	my $visibility = "full";#by the moment hardcoded in future it might be a parameter
                	my $color = "200,100,0";
                	my $altColor = "0,100,200";
                	my $priority = "20";
                	my $type = "bedGraph";
                	
			      	    print $F "track ";
				    	    print $F "type=$type ";	    				
    				    	print $F "name=", "\"cage ", $c, "\;", "ch", $nature, "\"", " ";
    				    	print $F "description=", "\"cage ", $c, "\;", $nature, "\"", " ";
    				    	print $F "visibility=", $visibility, " ";
    				    	if ($viewLimits ne "auto") {print $F "viewLimits=", $viewLimits, " ";} 
    				    	print $F "color=", $color, " ";
    				    	print $F "altcolor=", $altColor, " ";
    				    	print $F "priority=", $priority, " ";
    				    	print $F "\n";
                }  
                			
			      	#First header, always tagged by #h
#				    	print $F "#h;field;$winParam";
#				    	print $F "\n";
				    	
				    	for ($i = 0; $i < scalar (@$aryData); $i++)
				    		{
				    			my $hItem = $aryData->[$i];
				    			
				    			$acuValue = $hItem->{'acuValue'};				    							    		
				    			
				    			$chr = $hItem->{'chr'};
				    			$startInt = $hItem->{'startInt'};
				    			$endInt = $hItem->{'endInt'};
				    			
				    			if ($winMode eq "binary" && $acuValue != 0) 
							      {														        
							        $bin = 1;
							      }
							    elsif ($winMode eq "binary" && $acuValue == 0)
							      {
							        $bin = 0;
							      }
							    else
							      {    
							        $bin = $acuValue;
							      }
                  
                  if ($winFormat eq "rhmm")
                    {
				    			   print $F "#d;1;$i;$winParam;$acuValue;bin;$bin\n";
                    }
                  elsif ($winFormat eq "bedGraph")
                    {                                                                                       
                      if ($zerosOut ne "F") 
				    			     {
				    			       print $F "$chr\t$startInt\t$endInt\t$bin\n";
				    			     }
				    			   else 
				    			     {
				    			       if ($acuValue > 0)
				    			         {
				    			           print $F "$chr\t$startInt\t$endInt\t$bin\n";
				    			         }
				    			       else
				    			         {
				    			           ;
				    			         }
				    			     }	
                    }			    					    							    							    		
				    		}
				    	
				    	close ($F);
	      			print STDERR "      Results of cumulative window for $winParam of cage $c, channel $chN, nature $nature in: $file\n";
	  				}
	  		}
	  	
  }
  
sub joinCages
  {
    my $h = shift;		
		#my $caseGroup = $param->{caseGroup};
		my $caseGroup = shift;
		my $bindCageH = {};
		my $hashAryCh = {};
		my ($group, $i);
		my @aryJoinCh;
    my $hashNatureChN = {};
    
    foreach my $c (sort ({$a<=>$b} keys (%$h)))
	  		{	  	
	  		 
         if ($caseGroup eq "even" && $c % 2 == 0)  {$group = "case"}
	  		 if ($caseGroup eq "even" && $c % 2 != 0) {$group = "control"}
	  		 if ($caseGroup eq "odd" && $c % 2 == 0) {$group = "control"}
	  		 if ($caseGroup eq "odd" && $c % 2 != 0) {$group ="case"}
	  		  	  	  		  	  		   	  		   		   					     
	  		 foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
	  		   {
	  		     my $nature = $h->{$c}{$chN}{Nature};
	  		     if ($nature =~ /food_cd/) {$nature = "food_cd"}
	  		     if ($nature =~ /food_sc/ && $group eq "case") {$nature = "food_sc"}	  #cambio para dev phase		     
	  		     $hashNatureChN->{$group}{$nature} = $chN; 
	  		   }
	  		}
	  		     
		foreach my $c (sort ({$a<=>$b} keys (%$h)))
	  		{	  		  	  		  
	  		 if ($caseGroup eq "even" && $c % 2 == 0)  {$group = "case"}
	  		 if ($caseGroup eq "even" && $c % 2 != 0) {$group = "control"}
	  		 if ($caseGroup eq "odd" && $c % 2 == 0) {$group = "control"}
	  		 if ($caseGroup eq "odd" && $c % 2 != 0) {$group ="case"}  
	  		 	   					       
	  		 foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
	  		   {
	  		     my $data1 = ($h->{$c}{$chN}{data});
	  		     
	  		     #I check the nature and keep it as key so that data of same nature goes together
	  		     #at the end I reference back the natures to channel number
	  		     #In the case of free choice I don't want to separate into food_cd_3 and food_cd_4 that's why I join them
	  		     #by the same nature. The channel number corresponds of course to the last cage but it is not important
	  		     #as channel number keeps changing from 3 to 4
	  		     my $nature = $h->{$c}{$chN}{Nature};
	  		     
	  		     if ($nature =~ /food_cd/) {$nature = "food_cd"}
	  		     if ($nature =~ /food_sc/ && $group eq "case") {$nature = "food_sc"}#cambio para dev phase
	  		     
	  		     #my $data2 = ($bindCageH->{$group}{$chN}{data});
  		       my ($data2, $NInt, $NIntBind, $NIntCurr) = 0;  		       
  		       my $data2 = ($bindCageH->{$group}{$nature}{data});
  		       my @aryJoinCh;
  		       
  		       my $NIntCurr = scalar (@$data1);
  		       
  		       if (defined (@$data2)) 
  		        {
  		         $NIntBind = scalar (@$data2);
  		        }
  		       else 
  		        {
  		          $NIntBind = 0;
  		        } 
  		       
  		       $NInt = ($NIntCurr >= $NIntBind) ? $NIntCurr : $NIntBind; 
  		                       		     
#  		       for($i = 0; $i < scalar (@$data1)-1; $i++)
#  		       for($i = 0; $i < scalar (@$data1); $i++)            
  		       for($i = 0; $i < $NInt; $i++)  		           			         
  			       {
  				       my $h1 = $data1->[$i];
  				       my $h2 = $data2->[$i];
  				       my $hJoin = {};

  				       foreach my $key (keys (%$h1))
  					       {    					         					            					      
  					         if ($key =~ /acuValue/)
  							       {  							         
  							         $hJoin->{$key} = $h1->{$key} + $h2->{$key}; 
  							       }
  						        else 
  							       {
  								      $hJoin->{$key} = $h1->{$key};
  							       }	    					        
  					       }  				        
  				        push (@aryJoinCh, $hJoin);  				          				      
  			       }
  			       
#  			       delete ($bindCageH->{$group}{$chN}{data});
#              delete ($bindCageH->{$group}{$nature}{data});

#  			       $bindCageH->{$group}{$chN}{data} = \@aryJoinCh;
  			       $bindCageH->{$group}{$nature}{data} = \@aryJoinCh;
  			       
               $bindCageH->{$group}{$nature}{Nature} = $nature;

	  				}
	  		}
	  		
	  		my $newBindCageH = {};
	  			  		
	  		foreach my $g (sort ({$a<=>$b} keys (%$bindCageH)))
	  		 {
	  		   foreach my $n (sort ({$a<=>$b} keys(%{$bindCageH->{$g}})))
	  		     {
	  		       
	  		       my $num = $hashNatureChN->{$g}{$n};
	  		       $newBindCageH->{$g}{$num} = $bindCageH->{$g}{$n}
	  		     }
	  		 }
	  		
	  		#return ($bindCageH);
	  		#print Dumper ($newBindCageH);	  		
	  		return ($newBindCageH) ;
	  		
  }

#Join all the values belonging to the same time frame of the dark or light phase
#The length of the interval depends on win size as the input is the data already in windows
#sub joinByPhase
#  {
#    my $dWin = shift;
#    my $param = shift;
#    
#    my $deltaPh = 12;
#    my $winSize = exists ($param->{ws})? $param->{ws} : 1800;
#    
#    my ($start, $end, $firstPhLightChange, $startTimePh, $phase, $i); 
#    my $hPhaseBoundaries = {};
#    $start=$end=-1;
#    
#    #Traversing all intervals to set initial and end time   
#    ($start, $end) = &firstAndLastTime ($d, $param);
#    
#    $firstPhLightChange = &getFirstChange2LightPh ($d, $param, $start, $end);
#    
#    $i = 1;
#    $startTimePh = $firstPhLightChange - $start;
#    $phase = "light"; #I always start at light phase 8 AM
#
#    my ($hPh, $hCount) = {};
#    my $nextStartTimePh = "";
#
#    foreach my $c (sort ({$a<=>$b} keys(%$dWin)))
#  		{	
#  			foreach my $chN (sort ({$a<=>$b} keys(%{$dWin->{$c}})))
#  		    {	  		  					  						  					
#  			    my $data = $dWin->{$c}{$chN}{data};  			   
#  			    my $nature = $dWin->{$c}{$chN}{Nature};
#  			   
#            my $indexHash = {};
#            my $periodBefore1stPh = "TRUE";
#            my @aryJoinPh;
#            
#            $indexHash->{light} = 1;
#            $indexHash->{dark} = 1;
#            $nextStartTimePh = $startTimePh; 
#             
#            for ($i = 0; $i < scalar (@$data)-1; $i++)    			         
#  		       {
#  		         my $h1 = $data->[$i];
#  		         my $t = $h1->{endInt};  			         
#  		           			         
#  		         #In the previous version all intervals before the first entry from the beginning of the file into a light phase at 8:00 where skipped
#  		         #Here they are considered
#  		         if ($periodBefore1stPh eq "TRUE" && $t < $startTimePh)
#  		           { 
#  		             #Windows belonging to the previous not complete light phase (eg from file starting 10:00 to 20:00) 
#  		             if ($t <  ($startTimePh - $deltaPh * 3600) && $t >  ($startTimePh - $deltaPh * 3600 * 2))
#  		              {  		               
#  		                my $indexIntBefore = 3600 * 24 / $winSize + 1;  		                
#  		                my $time = 0;
#  		                
#  		                for ($time = $startTimePh; $t <  $time; $time = $time - $winSize)
#  		                  {  		                    
#  		                    $indexIntBefore--;
#  		                  }
#  		                  
#  		                 #print "LIGHT ---- $chN.\"::\".$nature $indexIntBefore   ------  $time \n";#del  		                 
#  		                 $hPh->{$c}{$chN."::".$nature}{light}{$indexIntBefore}{value} += $h1->{acuValue};
#  		                 $hPh->{$c}{$chN."::".$nature}{light}{$indexIntBefore}{count}++;
#  		              }
#  		              
#  		             #Windows belonging to dark phase just before first transition to light phase ocurring inside the file   		             
#  		             elsif ($t >  ($startTimePh - $deltaPh * 3600) && $t <  $startTimePh)
#  		              {
#  		                my $indexIntBefore = 3600 * 24 / $winSize / 2 + 1;
#  		                my $time = 0;
#  		                
#  		                for ($time = $startTimePh; $t <  $time; $time = $time - $winSize)
#  		                  {  		                    
#  		                    $indexIntBefore--;
#  		                  }
#  		                  
#  		                 #print "DARK ---- $chN.\"::\".$nature ---- $indexIntBefore   ------  $time \n";#del
#  		                 $hPh->{$c}{$chN."::".$nature}{dark}{$indexIntBefore}{value} += $h1->{acuValue};
#  		                 $hPh->{$c}{$chN."::".$nature}{dark}{$indexIntBefore}{count}++;
#  		              }
#  		              
#  		             else 
#  		              {
#  		                print STDERR "[FATAL] Impossible to asign day phase to interval occuring before first transition to light phase\n";
#  		                die;
#  		              }
#  		           }
#  		           
#  		         #While time it is inside the same phase I keep adding the values to the hash    			         
#  		         elsif ($t > $nextStartTimePh && $t <= $nextStartTimePh + $deltaPh * 3600)  			          
#  		           { 
#  		             $periodBefore1stPh = "FALSE";  		             
#  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{value} += $h1->{acuValue};
#  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{count}++;  		           
#  		             $indexHash->{$phase}++; 
#  		           }
#  		         elsif ($t > $nextStartTimePh + $deltaPh * 3600)
#  		           {  		  		                          
#  		             $phase = ($phase eq "light")? "dark" : "light";  		             
#  		             $indexHash->{$phase} = 1;
#                 	 #print "$phase\n";		               			          
#  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{value} += $h1->{acuValue};  		             
#  		             
#  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{count}++;
#  		             $nextStartTimePh = $nextStartTimePh + $deltaPh * 3600;
#  		             $indexHash->{$phase}++;		             
#  		           }
#  		       }
#  		    } 
#  		}  
#  		
#  	$hPh = &hashPh2hashWin ($hPh);
#    
#    if ($param->{winJoinPhFormat} eq "table")
#      {          
#        &hashPh2tblFile ($hPh);                            
#        die;
#      }
#    else 
#      {
#        return ($hPh);
#      }             
#  }
  
#Old version of the function before taking into account intervals occurring before first entry into light phase inside the file
sub joinByPhase
  {
    my $dWin = shift;
    my $param = shift;
    my $deltaPh = 12;
    
    my ($start, $end, $firstPhLightChange, $startTimePh, $phase, $i); 
    my $hPhaseBoundaries = {};
    $start=$end=-1;
    
    #Traversing all intervals to set initial and end time   
    ($start, $end) = &firstAndLastTime ($d, $param);
    
    $firstPhLightChange = &getFirstChange2LightPh ($d, $param, $start, $end);
    #print "###### start->$start end-->$end   first change to light --> $firstPhLightChange\n";#del
    #die;#del
    
    $i = 1;
    
    #is start more than 12 hours before first change to light phases? -> then start is occurring during the previous light phase     
    if ($start < ($firstPhLightChange - ($deltaPh * 3600)))
    	{
    	  $hPhaseBoundaries->{$i}{start} = $start - $start;
    	  $hPhaseBoundaries->{$i}{end} = $firstPhLightChange -($deltaPh * 3600) - $start;
    	  $hPhaseBoundaries->{$i}{phase} = "light";
    	  $i = $i + 1; 
    	  $hPhaseBoundaries->{$i}{start} = $firstPhLightChange -($deltaPh * 3600) - $start + 1;
    	  $hPhaseBoundaries->{$i}{end} = $firstPhLightChange - $start;
    	  $hPhaseBoundaries->{$i}{phase} = "dark";
    	  
    	  $startTimePh = $firstPhLightChange - $start;
    	  $phase = "light"; 
    	}
    else 
    	{
    	  $hPhaseBoundaries->{$i}{start} = $start - $start;
    	  $hPhaseBoundaries->{$i}{end} = $firstPhLightChange - $start;    	  
    	  $hPhaseBoundaries->{$i}{phase} = "dark";      	  
    	  $startTimePh = $firstPhLightChange - $start;
    	  $phase = "light";     		
    	}	
    #print "$firstPhLightChange ===== start->$start\n";#del
    my ($hPh, $hCount) = {};
    my $nextStartTimePh = "";
    
    #print "$startTimePh\n";#del
    #die;#del
    foreach my $c (sort ({$a<=>$b} keys(%$dWin)))
  		{	
  			foreach my $chN (sort ({$a<=>$b} keys(%{$dWin->{$c}})))
  		    {	  		  					  						  					
  			    my $data = $dWin->{$c}{$chN}{data};  			   
  			    my $nature = $dWin->{$c}{$chN}{Nature};
  			   
            my $indexHash = {};
            my $periodBefore1stPh = "TRUE";
            my @aryJoinPh;
            $phase = "light"; #I always start at light phase 8 AM
            $indexHash->{light} = 1;
            $indexHash->{dark} = 1;
            $nextStartTimePh = $startTimePh; 
             
            for ($i = 0; $i < scalar (@$data)-1; $i++)    			         
  		       {
  		         my $h1 = $data->[$i];
  		         my $t = $h1->{endInt};  			         
  		           			         
  		         #I jump all the intervals before the first entry from the beginning of the file into a light phase at 8:00
  		         if ($periodBefore1stPh eq "TRUE" && $t < $startTimePh)
  		           { 
  		             if ($nature eq "food_sc_3") {print "next--------------$t\n";}  			             			            
  		             next;
  		           }
  		         #While time it is inside the same phase I keep adding the values to the hash    			         
  		         elsif ($t > $nextStartTimePh && $t <= $nextStartTimePh + $deltaPh * 3600)  			          
  		           { 
  		             if ($nature eq "food_sc_3") {print "same phase $phase--------$t\n";}  			            
  		             $periodBefore1stPh = "FALSE";  		             
  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{value} += $h1->{acuValue};
  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{count}++;  		           
  		             $indexHash->{$phase}++; 
  		           }
  		         elsif ($t > $nextStartTimePh + $deltaPh * 3600)
  		           {  		  		                          
  		             $phase = ($phase eq "light")? "dark" : "light";
  		             if ($nature eq "food_sc_3") {print "change of phase $phase--------$t-----$h1->{acuValue}\n";}
  		             $indexHash->{$phase} = 1;
                 	 print "$phase\n";		               			          
  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{value} += $h1->{acuValue};  		             
  		             
  		             $hPh->{$c}{$chN."::".$nature}{$phase}{$indexHash->{$phase}}{count}++;
  		             $nextStartTimePh = $nextStartTimePh + $deltaPh * 3600;
  		             $indexHash->{$phase}++;		             
  		           }
  		       }
  		    } 
  		}  
  	#print Dumper ($hPh);	        
    $hPh = &hashPh2hashWin ($hPh);
    
    if ($param->{winJoinPhFormat} eq "table")
      {          
        &hashPh2tblFile ($hPh);                            
        die;
      }
    else 
      {
        return ($hPh);
      }             
  }

#Reformat the output of joinByPhase to a hash useful for default printing function of data2win (writeWindowBedFile and writeWindowBedFileSign)
sub hashPh2hashWin
  {
    my $hPh = shift;
    my $winSize = exists ($param->{ws})? $param->{ws} : 1800;
    my $hWin = {};
    
    foreach my $c (sort ({$a<=>$b} keys(%$hPh)))
  		{	
  		  foreach my $chN (sort ({$a<=>$b} keys(%{$hPh->{$c}})))
  		    {
  		      my ($natureN, $natureName);
  		      ($natureN, $natureName) = split ("::", $chN);
  		      
  		      foreach my $ph (sort ({$a<=>$b} keys(%{$hPh->{$c}{$chN}})))
  		        {
  		          my $startInt = 1;
  		          my $endInt = 1800;
  		          my @aryCh;
  		          
  		          foreach my $int (sort ({$a<=>$b} keys(%{$hPh->{$c}{$chN}{$ph}})))
  		            {
  		              
  		              my $intH = {};
  		              $intH->{'startInt'} = $startInt;
  		              $intH->{'endInt'} =  $endInt;
  		              $intH->{'chr'} = "chr1";
  		              if ($param->{winJoinPhase} eq "all")
  		                {
  		                  $intH->{'acuValue'} = $hPh->{$c}{$chN}{$ph}{$int}{'value'};
  		                }
  		              else
  		                {   
  		                  $intH->{'acuValue'} = $hPh->{$c}{$chN}{$ph}{$int}{'value'} / $hPh->{$c}{$chN}{$ph}{$int}{'count'} ;
  		                }
  		              push (@aryCh, $intH);
  		              
  		              $startInt += $winSize;
  		              $endInt += $winSize;     
  		            }
  		          
  		          $hWin->{$c.$ph}{$natureN}{Nature} = $natureName;
  		          $hWin->{$c.$ph}{$natureN}{data} = \@aryCh;  		                 
  		        } 
  		      #$natureName = 	
  		    }
  		}
  	return ($hWin);	

  }

#Outputs a file with all the values belonging to the same interval of the dark or light phase
#comming from joinByPhase() function
sub hashPh2tblFile
  {
    my $hPh = shift;
	my $winFile = $param -> {winFile}? $param -> {winFile} : "tablePhases";
	my $winParam = $param->{window};
	my $groupedCages = exists ($param->{winCage2comb})? 1 : 0;
	my $i = 0;
	my ($intRange, $acuValue);
	
	my $file = $winFile.".tbl";
    my $F= new FileHandle;
	vfopen ($F, ">$file");
  	
  	if ($groupedCages) {print $F "intN\tintRange\tcage\tnature\tvalue\n";}
  	else {print $F "intN\tintRange\tcage\tphase\tnature\tvalue\n";}	
    
    foreach my $c (sort ({$a<=>$b} keys(%$hPh)))
      {	
        foreach my $chN (sort ({$a<=>$b} keys(%{$hPh->{$c}})))
          {
            #my $nature = $hPh->{$c}{Nature};
            #print "$nature\n";
            
            my $nature = $hPh->{$c}{$chN}{Nature};
		    my $aryData = $hPh->{$c}{$chN}{data}; 
							  										    	
	    	for ($i = 0; $i < scalar (@$aryData); $i++)
	    		{
	    			my $hItem = $aryData->[$i];
	    			
	    			$acuValue = $hItem->{'acuValue'};				    							    		
	    			
	    			#$chr = $hItem->{'chr'};
	    			$intRange = $hItem->{'startInt'}."-".$hItem->{'endInt'};
	    			
	    			my $n = $i + 1;
	    			
	    			#Cages grouped by case control have a single field for phase and group (eg case_dark)
	    			if ($groupedCages)
	    			  { 
	    		        print $F "$n\t$intRange\t$c\t$nature\t$acuValue\n";
	    			  }
	    			#Individual cages have two fields one for cage and one for field  
	    			else
	    			  {			    			    
	    			    $c =~ m/^(\d+)([a-z]+)$/;			    			      
	    			    print $F "$n\t$intRange\t$1\t$2\t$nature\t$acuValue\n";
	    			  }  
	    		}			    				    	                      
          }
      }
    close ($F);
    print STDERR "      Table with values by phase intervals inside: $file\n";
  }
    
#This function plots channels set to combine by -winCh2comb as intervals of same range
#but different sign	
sub writeWindowBedFileSign
	{	
	  my $h = shift;
	  #print Dumper ($h);die;
		my $winFile = shift;
		my $winParam = $param->{window};
		my $zerosOut = $param->{zeroValues}? $param->{zeroValues} : "T";
			
		my $hUnitWin = shift;
		my ($hChComb) = {};
		my ($hJoinChUnitWin) = {};
				
		my ($comb, $i);
		
    my ($negativeSW) = &setSignChannels ($h);
		
		my $i = 0;
		my ($chr, $startInt, $endInt, $acuValue);
		
		#Defines the initial display mode of the annotation track. Values for display_mode include: 0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
		my $viewLimits = $param -> {winViewLim}? $param -> {winViewLim} : "0.5";
  	my $visibility = "full";#by the moment hardcoded in future it might be a parameter
  	my $color = "200,100,0";
  	my $altColor = "0,100,200";
  	my $priority = "20";
  	my $type = "bedGraph";	
    	
  	foreach my $c (sort ({$a<=>$b} keys(%$h)))
  		{	
  			foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
  				{	  				   		  					  						
  					if (exists ($negativeSW->{$c}{$chN}))
  					 {
  					   my $chNNegative = $negativeSW->{$c}{$chN};
  					   my $aryData = $h->{$c}{$chN}{data};
  					   my $aryDataNegative = $h->{$c}{$chNNegative}{data};
  					   my $nature = $h->{$c}{$chN}{Nature};
  					   my $natureNegative = $h->{$c}{$chNNegative}{Nature};
  					   
  					   my $file = $winFile."cage".$c."ch".$nature.$natureNegative.$chN.$chNNegative.".bedGraph";
  				
    					 my $F= new FileHandle;
    				
			      	 vfopen ($F, ">$file");
			      				
			      	 #Add track line specifications for the genome browser
			      	 #link to field info http://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
			    	   print $F "track ";
			    	   print $F "type=$type ";	    				
    		    	 print $F "name=", "\"cage ", $c, "\;", "ch", $nature, $natureNegative, "\"", " ";
    		    	 print $F "description=", "\"cage ", $c, "\;", $nature, $natureNegative, "\"", " ";
    		    	 print $F "visibility=", $visibility, " ";
    		    	 if ($viewLimits ne "auto") {print $F "viewLimits=", $viewLimits, " ";} 
    		    	 print $F "color=", $color, " ";
    		    	 print $F "altcolor=", $altColor, " ";
    		    	 print $F "priority=", $priority, " ";
    		    	 print $F "\n";
			    	     
			    	   my $NInt = (scalar (@$aryData) >= scalar (@$aryDataNegative))? scalar (@$aryData) : scalar (@$aryDataNegative);

			    	   for ($i = 0; $i < $NInt; $i++)
			    		   {
			    		     if (exists ($aryData->[$i]))
			    		       {			    		     
			    		         my $hItem = $aryData->[$i];			    			       
			    			       $chr = $hItem->{'chr'};
			    			       $startInt = $hItem->{'startInt'};
			    			       $endInt = $hItem->{'endInt'};
			    			       $acuValue = $hItem->{'acuValue'};
			    			       
			    			       if ($zerosOut ne "F") 
				    			       {
				    			         print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			       }
				    			     else 
				    			       {
				    			         if ($acuValue != 0)
				    			           {
				    			             print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			           }
				    			         else
				    			           {
				    			             ;
				    			           }
				    			       }
				    			       				    			       
			    		       }
			    		     if (exists ($aryDataNegative->[$i]))
			    		       {			    		     
			    		         my $hItem = $aryDataNegative->[$i];			    			       
			    			       $chr = $hItem->{'chr'};
			    			       $startInt = $hItem->{'startInt'};
			    			       $endInt = $hItem->{'endInt'};
			    			       $acuValue = -$hItem->{'acuValue'}; 
			    			       
			    			       if ($zerosOut ne "F") 
				    			       {
				    			         print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			       }
				    			     else 
				    			       {
				    			         if ($acuValue != 0)
				    			           {
				    			             print $F "$chr\t$startInt\t$endInt\t$acuValue\n";
				    			           }
				    			         else
				    			           {
				    			             ;
				    			           }
				    			       }
			    		       }
			    		         
			    		   }
			    	
			    	   close ($F);
      				 print STDERR "      Results of cumulative window for $winParam of cage $c, channel $chN, nature $nature in: $file\n";
  					 }
  				  else
  				    {
  				      next;
  				    }
  				}
  		}
	  			  							
	}

#Function sets which channels are going to be plot as negative values. 
#The general criteria is for food:channels are set to positive if they contain SC 
#                        for liquid: channels are set to positive if they contain Water 
#                        if they have the same nature then the 1st is positive and the 2nd negative   
sub setSignChannels
		{
		  my $h = shift;
		  my $hChComb = &readWinComb ();
		  my $comb;
		  my $natures = {}; 		  
		  my $negativeSW = {};
		  my $positiveNature = "";
		  
		  foreach my $c (sort ({$a<=>$b} keys(%$h)))
  		  {	
  			 foreach my $chN (sort ({$a<=>$b} keys(%{$h->{$c}})))
  			   {		  		
  				    $natures->{$c}{$chN} = $h->{$c}{$chN}{Nature};  				    	  					
  				 }
  			 next;  			 	
  		  }
  					   
		  foreach $comb (keys (%$hChComb))
	  				{	  					
	  					if ( exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"2"}) && exists ($hChComb->{$comb}{"3"}) && exists ($hChComb->{$comb}{"4"})
	  					     ||exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"3"}) || exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"4"}) 
	  						   || exists ($hChComb->{$comb}{"2"}) && exists ($hChComb->{$comb}{"3"}) || exists ($hChComb->{$comb}{"2"}) && exists ($hChComb->{$comb}{"4"}))	  							
	  					  {
	  					    print STDERR "FATAL ERROR: -winCombMode does not allow this channel combination $param -> {winCh2comb}\n"; 
	  					  } 
	  					
	  					elsif (exists ($hChComb->{$comb}{"1"}) && exists ($hChComb->{$comb}{"2"})) 
	  						{	  							
	  							
	  							#$negativeSW = &setNegativeCh ($ch1, $ch2, $positiveNature, $hashNatures);
	  							$positiveNature = "water";
	  							$negativeSW = &setNegativeCH ("1", "2", $positiveNature, $natures, $negativeSW);	  								  						
	  						}	
	  							 	  							  					
	  					elsif (exists ($hChComb->{$comb}{"3"}) && exists ($hChComb->{$comb}{"4"}))
	  					  {
	  					    $positiveNature = "food_sc";
	  					    $negativeSW = &setNegativeCH ("3", "4", $positiveNature, $natures, $negativeSW);	  					    	  					   
	  					  }
	  				}
	  				
	   return ($negativeSW);
		}

#This function gets a nature from which values will be positive bars inside bedgraph file
#search this nature and if it founds it the other channel is set to negative
#Right now if both channels have the same nature first occurrence set to positive and
#second to negative, I might also change this and in this case set a flag to cumulate
#this values in the same track depending of how clear are figures
sub setNegativeCH
  {
    my $ch1 = shift;
    my $ch2 = shift;
    my $positiveNature = shift;
    my $hashNatures = shift;
    my $negativeSW = shift;
        
    foreach my $c (sort ({$a<=>$b} keys (%$hashNatures)))
      {
        my $v =$hashNatures->{$c}{$ch1} ; 
        
        if ($hashNatures->{$c}{$ch1} eq $positiveNature) 
  	      {  	        
  	        $negativeSW->{$c}{$ch1} = $ch2;
  	      }
  	    elsif ($hashNatures->{$c}{$ch2} eq $positiveNature)
  	      {	  	  	        					   
  	        $negativeSW->{$c}{$ch2} = $ch1;
  	      }
  	    #it might be that both channels contain different things  
  	    else
  	      {
  	        $negativeSW->{$c}{$ch1} = $ch2;
  	      }     		                    
      }
      
    return ($negativeSW);
  }		
  
sub splitAry 
	{
		my $ary = shift;
		my $tag = shift;
		my $hItems = shift;
		my $i = shift;
		
		my (@aryItems, $k);
		
		@aryItems = split ($tag, $ary);
						
		foreach $k (@aryItems)
			{
				$hItems->{$i}{$k}++;						
			}
									
		return ($hItems);		
	}				
	      									
sub vfopen 
  {
    my $f=shift;
    my $file=shift;

    if (($file =~/^\>/) && !($file =~/^\>\>/ )){open ($f, $file); return $f;}
    elsif (($file =~/^\>\>(.*)/))
      {
	if (!-e $1){	print STDERR "\nERROR: $file does not exist [FATAL]\n";exit(1);}
      }
    elsif (!-e $file){	print STDERR "\nERROR: $file does not exist [FATAL]\n";exit(1);}
   
    open ($f,$file);
    return $f;
  }	
  
sub setOutputName
  {
    my $param=shift;
    
    if (!$param->{out})
      {
		$param->{out}=$param->{data};
		$param->{out}=~s/\.[^\.]*$//;
	  }
    
    if (!$param->{outBed}) {$param->{outBed} = "$param->{out}";}
    if (!$param->{outCytoband}) {$param->{outCytoband} = "$param->{out}";}
    if (!$param->{outPhaseBed}) {$param->{outPhaseBed} = "$param->{out}";}
    if (!$param->{outGenome}) {$param->{outGenome} = "$param->{out}";}
    
    return $param;
  }  

sub setAllOptions
	{
		my $param=shift;
		
		if (!exists ($param->{out})) 
			{
				$param->{out} = "out_";
				print STDERR "It is advisable to set a prefix for all the produced files when using \"allFiles genomeBrowser\" parameter\n";
			}
		
		$param->{cytobandFile} = 1;
		$param->{convert} = "int2bed";
		$param->{create} = "chr";
		$param->{timeDivision} = 1;
		$param->{files2bed} = 1;
		$param->{phase2bed} = 1;
		#$param->{window} = "Value" ;
		$param->{window} = exists ($param->{window})? $param->{window} : "Value";
		$param->{ws} = "1800" ;
		$param->{wss} = "1800" ;
				
		$param->{outCytoband} = exists ($param->{outCytoband})? $param->{outCytoband} : $param->{out};
		$param->{outBed} = exists ($param->{outBed})? $param->{outBed} : $param->{out};
		$param->{outGenome} = exists ($param->{outGenome})? $param->{outGenome} : $param->{out};
		$param->{outTimeDiv} = exists ($param->{outTimeDiv})? $param->{outTimeDiv} : $param->{out};
		$param->{outFileDiv} = exists ($param->{outFileDiv})? $param->{outFileDiv} : $param->{out};
		$param->{outPhaseBed} = exists ($param->{outPhaseBed})? $param->{outPhaseBed} : $param->{out};
		$param->{winFile} = exists ($param->{winFile})? $param->{winFile} : $param->{out};

		return ($param);		
	}

sub path2fileName 
  {
    my $f = shift;
                  
    if ($f =~ /^*.\//) #avoiding names as us/cn/file.act -> file.act  #REVIEW!!!!!
      {      
        my @a = split ("/",$f);        
        $f = pop (@a);      
      } 
    	
    return ($f);
    
  }
  
sub euclideanAlgGCD 
	{
    	my $a = $_[0];
    	my $b = $_[1];
    	my $c;

	    # $a should be always bigger than $b
	    if ( $a < $b ) { ( $a, $b ) = ( $b, $a ) }

    	# loop while remainder is not equal to 0
    	while ( ($b > 0) and (( $a % $b ) != 0) ) 
    		{
        		$c = $b;
        		$b = $a % $b;
        		$a = $c;
        	}

    	return ($b);
	}
	  